opening dump file "D:\AADL\BHA\osate2\dump.txt" Sun Nov 02 17:09:44 CST 2014
opening proof script file "D:\AADL\BHA\osate2\script.txt"
new script
launching BLESS plug-in . . .
You chose proof script: D:\AADL\BHA\osate2\workspace\WLCS\proofscripts/iscript.txt
Executing proof script . . .
****Load****

Starting to gather BLESS/subBLESS annex subclauses, Assertion annex libraries, and
 Assertion properties of features from packages open in the workspace.

The model is being loaded into BLESS.
Gathering property set "Memory_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@7052a520 (name: Memory_Properties)
What should be done with property associations?
Gathering property set "Communication_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@4628c3f8 (name: Communication_Properties)
What should be done with property associations?
Gathering property set "ARP4761".
psi:  org.osate.aadl2.impl.PropertySetImpl@3bb61952 (name: ARP4761)
What should be done with property associations?
Gathering property set "Modeling_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@457cc778 (name: Modeling_Properties)
What should be done with property associations?
Gathering property set "AADL_Project".
psi:  org.osate.aadl2.impl.PropertySetImpl@30bbaec (name: AADL_Project)
What should be done with property associations?
Gathering property set "ARINC653".
psi:  org.osate.aadl2.impl.PropertySetImpl@5b940804 (name: ARINC653)
What should be done with property associations?
Gathering property set "Behavior_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@1cf17880 (name: Behavior_Properties)
What should be done with property associations?
Gathering property set "Data_Model".
psi:  org.osate.aadl2.impl.PropertySetImpl@311e2a58 (name: Data_Model)
What should be done with property associations?
Gathering property set "WLCS_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@336e1099 (name: WLCS_Properties)
What should be done with property associations?
Gathering property set "EMV2".
psi:  org.osate.aadl2.impl.PropertySetImpl@7f03c72f (name: EMV2)
What should be done with property associations?
Gathering property set "Thread_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@2b0dba35 (name: Thread_Properties)
What should be done with property associations?
Gathering property set "BLESS".
psi:  org.osate.aadl2.impl.PropertySetImpl@71df94bc (name: BLESS)
What should be done with property associations?
Gathering property set "Deployment_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@d9dfd0c (name: Deployment_Properties)
What should be done with property associations?
Gathering property set "Programming_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@7f5025cf (name: Programming_Properties)
What should be done with property associations?
Gathering property set "ARINC429".
psi:  org.osate.aadl2.impl.PropertySetImpl@4a1bc451 (name: ARINC429)
What should be done with property associations?
Gathering property set "SEI".
psi:  org.osate.aadl2.impl.PropertySetImpl@64f5c7d9 (name: SEI)
What should be done with property associations?
Gathering property set "MILSTD882".
psi:  org.osate.aadl2.impl.PropertySetImpl@46464bd9 (name: MILSTD882)
What should be done with property associations?
Gathering property set "BLESS_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@6ec61bda (name: BLESS_Properties)
What should be done with property associations?
Gathering property set "Timing_Properties".
psi:  org.osate.aadl2.impl.PropertySetImpl@7f067173 (name: Timing_Properties)
What should be done with property associations?
Gathering package "ErrorLibrary".
There are no component types in package "ErrorLibrary".
All component types in package "ErrorLibrary" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
ErrorLibrary has no component implementations.
Done with package ErrorLibrary.

Gathering package "Base_Types".
Creating a parse record for a "data" component type named "Boolean".
looking for features with BLESS::Assertion properties in Boolean
Boolean has no features.
Creating a parse record for a "data" component type named "Integer".
looking for features with BLESS::Assertion properties in Integer
Integer has no features.
Creating a parse record for a "data" component type named "Integer_8".
looking for features with BLESS::Assertion properties in Integer_8
Integer_8 has no features.
Creating a parse record for a "data" component type named "Integer_16".
looking for features with BLESS::Assertion properties in Integer_16
Integer_16 has no features.
Creating a parse record for a "data" component type named "Integer_32".
looking for features with BLESS::Assertion properties in Integer_32
Integer_32 has no features.
Creating a parse record for a "data" component type named "Integer_64".
looking for features with BLESS::Assertion properties in Integer_64
Integer_64 has no features.
Creating a parse record for a "data" component type named "Unsigned_8".
looking for features with BLESS::Assertion properties in Unsigned_8
Unsigned_8 has no features.
Creating a parse record for a "data" component type named "Unsigned_16".
looking for features with BLESS::Assertion properties in Unsigned_16
Unsigned_16 has no features.
Creating a parse record for a "data" component type named "Unsigned_32".
looking for features with BLESS::Assertion properties in Unsigned_32
Unsigned_32 has no features.
Creating a parse record for a "data" component type named "Unsigned_64".
looking for features with BLESS::Assertion properties in Unsigned_64
Unsigned_64 has no features.
Creating a parse record for a "data" component type named "Natural".
looking for features with BLESS::Assertion properties in Natural
Natural has no features.
Creating a parse record for a "data" component type named "Float".
looking for features with BLESS::Assertion properties in Float
Float has no features.
Creating a parse record for a "data" component type named "Float_32".
looking for features with BLESS::Assertion properties in Float_32
Float_32 has no features.
Creating a parse record for a "data" component type named "Float_64".
looking for features with BLESS::Assertion properties in Float_64
Float_64 has no features.
Creating a parse record for a "data" component type named "Character".
looking for features with BLESS::Assertion properties in Character
Character has no features.
Creating a parse record for a "data" component type named "String".
looking for features with BLESS::Assertion properties in String
String has no features.
All component types in package "Base_Types" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
Base_Types has no component implementations.
Done with package Base_Types.

Gathering package "BLESS_Types".
Creating a parse record for a "data" component type named "Integer".
  data type "Integer" has BLESS::Typed property "integer".
Integer BLESS::Typed property unparsed:  integer
looking for features with BLESS::Assertion properties in Integer
Integer has no features.
Creating a parse record for a "data" component type named "Natural".
  data type "Natural" has BLESS::Typed property "natural".
Natural BLESS::Typed property unparsed:  natural
looking for features with BLESS::Assertion properties in Natural
Natural has no features.
Creating a parse record for a "data" component type named "Real".
  data type "Real" has BLESS::Typed property "real".
Real BLESS::Typed property unparsed:  real
looking for features with BLESS::Assertion properties in Real
Real has no features.
Creating a parse record for a "data" component type named "String".
  data type "String" has BLESS::Typed property "string".
String BLESS::Typed property unparsed:  string
looking for features with BLESS::Assertion properties in String
String has no features.
Creating a parse record for a "data" component type named "Fixed_Point".
  data type "Fixed_Point" has BLESS::Typed property "rational".
Fixed_Point BLESS::Typed property unparsed:  rational
looking for features with BLESS::Assertion properties in Fixed_Point
Fixed_Point has no features.
Creating a parse record for a "data" component type named "Time".
  data type "Time" has BLESS::Typed property "real".
Time BLESS::Typed property unparsed:  real
looking for features with BLESS::Assertion properties in Time
Time has no features.
Creating a parse record for a "data" component type named "flag".
  data type "flag" has BLESS::Typed property "boolean".
flag BLESS::Typed property unparsed:  boolean
looking for features with BLESS::Assertion properties in flag
flag has no features.
All component types in package "BLESS_Types" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
BLESS_Types has no component implementations.
Done with package BLESS_Types.

Gathering package "WLCS_Types".
Creating a parse record for a "data" component type named "ControlCommand".
looking for features with BLESS::Assertion properties in ControlCommand
ControlCommand has no features.
Creating a parse record for a "data" component type named "ValveStatus".
looking for features with BLESS::Assertion properties in ValveStatus
ValveStatus has no features.
Creating a parse record for a "data" component type named "WaterLevel".
  data type "WaterLevel" has BLESS::Typed property "real".
WaterLevel BLESS::Typed property unparsed:  real
looking for features with BLESS::Assertion properties in WaterLevel
WaterLevel has no features.
Creating a parse record for a "data" component type named "SensorValue".
looking for features with BLESS::Assertion properties in SensorValue
SensorValue has no features.
Creating a parse record for a "data" component type named "Time".
looking for features with BLESS::Assertion properties in Time
Time has no features.
Creating a parse record for a "data" component type named "on_off".
  data type "on_off" has BLESS::Typed property "enumeration (Off, On)".
on_off BLESS::Typed property unparsed:  enumeration (Off, On)
looking for features with BLESS::Assertion properties in on_off
on_off has no features.
All component types in package "WLCS_Types" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
WLCS_Types has no component implementations.
Done with package WLCS_Types.

Gathering package "WLCS".
Creating a parse record for a "system" component type named "WLCS".
looking for features with BLESS::Assertion properties in WLCS
WLCS has no features.
Creating a parse record for a "process" component type named "pController".
Process component with name of "pController" had no BLESS to gather.
looking for features with BLESS::Assertion properties in pController
  feature sw org.osate.aadl2.impl.DataPortImpl@6cd900d2 (name: sw) (direction: in) on line 0
  feature cc org.osate.aadl2.impl.DataPortImpl@43611931 (name: cc) (direction: out) on line 0
  feature "cc" has BLESS::Typed property "enumeration (Off, On)".
cc as string tree:  ^(enumeration Off On )
cc as unparsed:  enumeration (Off, On)
Creating a parse record for a "thread" component type named "Controller".
looking for features with BLESS::Assertion properties in Controller
  feature sw org.osate.aadl2.impl.DataPortImpl@15f0b9a4 (name: sw) (direction: in) on line 0
  feature cc org.osate.aadl2.impl.EventDataPortImpl@351d6f7 (name: cc) (direction: out) on line 0
  feature "cc" has BLESS::Assertion property "<<:=COMMAND()>>".
cc as string tree:  ^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
cc as unparsed:  << := COMMAND()>> 
  feature "cc" has BLESS::Typed property "enumeration (Off, On)".
cc as string tree:  ^(enumeration Off On )
cc as unparsed:  enumeration (Off, On)
Creating a parse record for a "abstract" component type named "WaterTank".
Abstract component with name of "WaterTank" had no BLESS to gather.
looking for features with BLESS::Assertion properties in WaterTank
  feature wl org.osate.aadl2.impl.DataPortImpl@55a99ff8 (name: wl) (direction: out) on line 0
  feature "wl" has BLESS::Typed property "real".
wl as string tree:  real
wl as unparsed:  real
  feature ac org.osate.aadl2.impl.EventDataPortImpl@6d98e6aa (name: ac) (direction: in) on line 0
Creating a parse record for a "device" component type named "Actuator".
looking for features with BLESS::Assertion properties in Actuator
  feature cc org.osate.aadl2.impl.EventDataPortImpl@51ba34f8 (name: cc) (direction: in) on line 0
  feature "cc" has BLESS::Typed property "enumeration (Off, On)".
cc as string tree:  ^(enumeration Off On )
cc as unparsed:  enumeration (Off, On)
  feature ac org.osate.aadl2.impl.EventDataPortImpl@7d767486 (name: ac) (direction: out) on line 0
Creating a parse record for a "device" component type named "sensor".
looking for features with BLESS::Assertion properties in sensor
  feature wl org.osate.aadl2.impl.DataPortImpl@4b6ed887 (name: wl) (direction: in) on line 0
  feature "wl" has BLESS::Typed property "real".
wl as string tree:  real
wl as unparsed:  real
  feature sw org.osate.aadl2.impl.DataPortImpl@bf09f2b (name: sw) (direction: out) on line 0
All component types in package "WLCS" have had their BLESS annex subclauses parsed, and feature names mapped to their Assertions.
  Starting to gather component implementations.
  gathering component implementation "WLCS.impl"
Looking for component type "WLCS", defining features this implementation uses.
no subprogram access map for component WLCS
  gathering component implementation "pController.impl"
  gathering component implementation "Controller.impl"
Found a BLESS annex subclause in component implementation "Controller.impl" in package "WLCS".
parsing Controller.impl
Controller.impl has loaded type maps
unparsed:
annex BLESS
{**  --Controller.impl
assert 
  <<UNDERFLOW: :sw <= 29>>
  <<OVERFLOW: :sw >= 61>>
  <<STAY_SAME: :(sw > 30) and (sw < 60)>>
  <<TURN_ON: :sw <= 30>>
  <<TURN_OFF: :sw >= 60>>
  <<COMMAND: := (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, 
                   (TURN_ON()) -> On>>  
invariant <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
variables
  cv: WLCS_Types::on_off:=Off; 
states
  START : initial state
    <<cv = Off>>;
  FILL : complete state
    <<cv = On and (TURN_ON() or STAY_SAME())>>;
  DRAIN : complete state
    <<cv = Off and (TURN_OFF() or STAY_SAME())>>;
  CHECK_FILL : state
    <<cv = On and (TURN_ON() or STAY_SAME())>>;
  CHECK_DRAIN : state
    <<cv = Off and (TURN_OFF() or STAY_SAME())>>;
  OVER_FLOW : final state
    <<OVERFLOW()>>;
  UNDER_FLOW : final state
    <<UNDERFLOW()>>;
transitions
  T0_start: START-[sw >= 60]->DRAIN
    { cc!(Off)
       ;
       <<TURN_OFF()>>
       cv := Off
       <<cv = Off and (TURN_OFF() or STAY_SAME())>> }
   ;  --end of T0_start

  T1_start: START-[sw <= 30]->FILL
    { cc!(On)
       ;
       <<TURN_ON()>>
       cv := On
       <<cv = On and (TURN_ON() or STAY_SAME())>> }
   ;  --end of T1_start

  T2_start: START-[(sw > 30) and (sw < 60)]->DRAIN
    { cc!(nc)
       <<cv = Off and (TURN_OFF() or STAY_SAME())>> }
   ;  --end of T2_start

  T3_check_fill: FILL-[on dispatch]->CHECK_FILL
    {} ;  --end of T3_check_fill

  T4_fill_ok: CHECK_FILL-[(cv = On) and (((sw > 30) and (sw < 60)) or 
  (sw <= 30))]->FILL
    { cc!(nc)
       <<cv = On and (TURN_ON() or STAY_SAME())>> }
   ;  --end of T4_fill_ok

  T5_fill_out: CHECK_FILL-[sw >= 60]->DRAIN
    { cc!(Off)
       ;
       <<TURN_OFF()>>
       cv := Off
       <<cv = Off and (TURN_OFF() or STAY_SAME())>> }
   ;  --end of T5_fill_out

  T6_check_drain: DRAIN-[on dispatch]->CHECK_DRAIN
    {} ;  --end of T6_check_drain

  T7_drain_ok: CHECK_DRAIN-[(cv = Off) and (((sw > 30) and (sw < 60)) or 
  (sw >= 60))]->DRAIN
    { cc!(nc)
       <<cv = Off and (TURN_OFF() or STAY_SAME())>> }
   ;  --end of T7_drain_ok

  T8_drain_out: CHECK_DRAIN-[sw <= 30]->FILL
    { cc!(On)
       ;
       <<TURN_ON()>>
       cv := On
       <<cv = On and (TURN_ON() or STAY_SAME())>> }
   ;  --end of T8_drain_out

  T9_overflow: CHECK_FILL-[sw >= 61]->OVER_FLOW
    {} ;  --end of T9_overflow

  T10_underflow: CHECK_DRAIN-[sw <= 29]->UNDER_FLOW
    {} ;  --end of T10_underflow
**}  --Controller.impl
Looking for component type "Controller", defining features this implementation uses.
no subprogram access map for component Controller
  gathering component implementation "WaterTank.impl"
  gathering component implementation "actuator.impl"
Looking for component type "actuator", defining features this implementation uses.
There was no component type "actuator" found in package "WLCS" for component implementation "actuator.impl".
  gathering component implementation "sensor.impl"
Looking for component type "sensor", defining features this implementation uses.
no subprogram access map for component sensor
Done with package WLCS.

Data Component Name to Type map={WLCS_Types::WaterLevel=real, BLESS_Types::Natural=natural, WLCS_Types::on_off=enumeration, BLESS_Types::Integer=integer, BLESS_Types::Fixed_Point=rational, BLESS_Types::flag=boolean, BLESS_Types::Time=real, BLESS_Types::Real=real, BLESS_Types::String=string}
Type Checking . . .
Creating proof obligations for components having BLESS or subBLESS annex subclauses.
 extracting initial proof obligation(s) for a package:  "ErrorLibrary"
 extracting initial proof obligation(s) for a package:  "Base_Types"
  no proof obligations created for "Float"
  no proof obligations created for "Integer_64"
  no proof obligations created for "Integer_16"
  no proof obligations created for "Unsigned_64"
  no proof obligations created for "Natural"
  no proof obligations created for "Unsigned_8"
  no proof obligations created for "Boolean"
  no proof obligations created for "Character"
  no proof obligations created for "Integer_8"
  no proof obligations created for "Unsigned_16"
  no proof obligations created for "String"
  no proof obligations created for "Float_64"
  no proof obligations created for "Unsigned_32"
  no proof obligations created for "Float_32"
  no proof obligations created for "Integer_32"
  no proof obligations created for "Integer"
 extracting initial proof obligation(s) for a package:  "BLESS_Types"
  no proof obligations created for "Real"
  no proof obligations created for "flag"
  no proof obligations created for "Time"
  no proof obligations created for "String"
  no proof obligations created for "Natural"
  no proof obligations created for "Fixed_Point"
  no proof obligations created for "Integer"
 extracting initial proof obligation(s) for a package:  "WLCS_Types"
  no proof obligations created for "Time"
  no proof obligations created for "SensorValue"
  no proof obligations created for "WaterLevel"
  no proof obligations created for "on_off"
  no proof obligations created for "ControlCommand"
  no proof obligations created for "ValveStatus"
 extracting initial proof obligation(s) for a package:  "WLCS"
  creating proof obligations for "sensor"
extracting proof obligations for "sensor"
  no proof obligations created for "pController"
  creating proof obligations for "Actuator"
extracting proof obligations for "Actuator"
  creating proof obligations for "Controller"
extracting proof obligations for "Controller"
  creating proof obligations for "WLCS"
extracting proof obligations for "WLCS"
  no proof obligations created for "WaterTank"
  creating proof obligations for "sensor.impl"
extracting proof obligations for "sensor.impl"
  creating proof obligations for "WLCS.impl"
extracting proof obligations for "WLCS.impl"
  creating proof obligations for "Controller.impl"
extracting proof obligations for "Controller.impl"
making initial obligations for complete states
making Serban's theorems
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
making initial proof obligations for transitions
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
  creating proof obligations for "actuator.impl"
extracting proof obligations for "actuator.impl"
Creating assume-guaranty proof obligations for port connections. (TBD)
connection proof obligations for package "ErrorLibrary"
connection proof obligations for package "Base_Types"
connection proof obligations for package "BLESS_Types"
connection proof obligations for package "WLCS_Types"
connection proof obligations for package "WLCS"
connection proof obligations for component implementation "WLCS.impl"
connection "WLCS::WLCS.impl.C2A" has no source or destination Assertions.
connection "WLCS::WLCS.impl.A2W" has no source or destination Assertions.
connection "WLCS::WLCS.impl.W2S" has no source or destination Assertions.
connection "WLCS::WLCS.impl.S2C" has no source or destination Assertions.
connection proof obligations for component implementation "pController.impl"
connection "WLCS::pController.impl.C1" has no source or destination Assertions.
connection "WLCS::pController.impl.C2" has no destination Assertion.
connection proof obligations for component implementation "Controller.impl"
connection proof obligations for component implementation "WaterTank.impl"
connection proof obligations for component implementation "actuator.impl"
connection proof obligations for component implementation "sensor.impl"
composition proof obligations for package "ErrorLibrary"
composition proof obligations for package "Base_Types"
composition proof obligations for package "BLESS_Types"
composition proof obligations for package "WLCS_Types"
composition proof obligations for package "WLCS"
Global.compilationUnits.size()=5
Global.compilationUnitStartingProductions.size()=0
Proof.label_assertion_map={TURN_OFF=ASSERTION[130], STAY_SAME=ASSERTION[128], OVERFLOW=ASSERTION[127], TURN_ON=ASSERTION[129], UNDERFLOW=ASSERTION[126], COMMAND=ASSERTION_FUNCTION[133]}
Declarative Model is Loaded into BLESS.
No errors found.
****make-an****
Making obligation 0
Obligations:

[serial 1003]: WLCS::Controller.impl
P [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [78]->
Q [78] <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
  What for: <<M(FILL)>> -> <<I>> from invariant I when complete state FILL has Assertion <<M(FILL)>> in its definition.


Done making obligation 0
#WLCS::Controller.impl
#[serial 1003] <<M(FILL)>> -> <<I>> from invariant I when complete state FILL has Assertion <<M(FILL)>> in its definition.
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 (TURN_ON() or STAY_SAME())


This Proof Obligation:

[serial 1003]: WLCS::Controller.impl
P [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [78]->
Q [78] <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for: <<M(FILL)>> -> <<I>> from invariant I when complete state FILL has Assertion <<M(FILL)>> in its definition.

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [11.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1004]: WLCS::Controller.impl
P [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [78]->
Q [78] <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
  What for: <<M(DRAIN)>> -> <<I>> from invariant I when complete state DRAIN has Assertion <<M(DRAIN)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1004] <<M(DRAIN)>> -> <<I>> from invariant I when complete state DRAIN has Assertion <<M(DRAIN)>> in its definition.
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 (TURN_OFF() or STAY_SAME())


This Proof Obligation:

[serial 1004]: WLCS::Controller.impl
P [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [78]->
Q [78] <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for: <<M(DRAIN)>> -> <<I>> from invariant I when complete state DRAIN has Assertion <<M(DRAIN)>> in its definition.

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [11.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1005]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [93]->
Q [93] <<((cv = On)
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30)))
or (sw >= 60)
or (sw >= 61)>>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_FILL, <<M(CHECK_FILL)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1005] Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_FILL, <<M(CHECK_FILL)>> -> <<e1 or e2 or . . . en>>
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1005]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [93]->
Q [93] <<((cv = On)
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30)))
or (sw >= 60)
or (sw >= 61)>>
Reason:  Substitution of Assertion Labels
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_FILL, <<M(CHECK_FILL)>> -> <<e1 or e2 or . . . en>>

Has substituted Assertions' predicates for labels to get:

[serial 1018]: WLCS::Controller.impl
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))>>
S [93]->
Q [93] <<((cv = On)
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30)))
or (sw >= 60)
or (sw >= 61)>>
  What for: substituted Assertions' predicates for  labels  [serial 1005]

. . . done Substituting Assertions for Labels [11.0 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1018]: WLCS::Controller.impl
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))>>
S [93]->
Q [93] <<((cv = On)
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30)))
or (sw >= 60)
or (sw >= 61)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1005]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1020]: WLCS::Controller.impl
P [93] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
S [93]->
Q [93] <<60 <= sw
or 61 <= sw
or (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))>>
  What for:   normalization of [serial 1018]

. . . done Normalizing Unsolved Proof Obligations [11.1 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1020]: WLCS::Controller.impl
P [93] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
S [93]->
Q [93] <<60 <= sw
or 61 <= sw
or (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))>>
  What for:   normalization of [serial 1018]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [11.1 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [11.1 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1020]: WLCS::Controller.impl
P [93] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
S [93]->
Q [93] <<60 <= sw
or 61 <= sw
or (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))>>
Reason:  Or Introduction Schema (orcwl):  X->(X or Y)
  What for:   normalization of [serial 1018]

Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)
. . . done Applying Axioms [11.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1006]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [94]->
Q [94] <<((cv = Off)
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60)))
or (sw <= 30)
or (sw <= 29)>>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_DRAIN, <<M(CHECK_DRAIN)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1006] Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_DRAIN, <<M(CHECK_DRAIN)>> -> <<e1 or e2 or . . . en>>
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1006]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [94]->
Q [94] <<((cv = Off)
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60)))
or (sw <= 30)
or (sw <= 29)>>
Reason:  Substitution of Assertion Labels
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_DRAIN, <<M(CHECK_DRAIN)>> -> <<e1 or e2 or . . . en>>

Has substituted Assertions' predicates for labels to get:

[serial 1023]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))>>
S [94]->
Q [94] <<((cv = Off)
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60)))
or (sw <= 30)
or (sw <= 29)>>
  What for: substituted Assertions' predicates for  labels  [serial 1006]

. . . done Substituting Assertions for Labels [11.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1023]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))>>
S [94]->
Q [94] <<((cv = Off)
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60)))
or (sw <= 30)
or (sw <= 29)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1006]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1025]: WLCS::Controller.impl
P [94] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
S [94]->
Q [94] <<sw <= 30
or sw <= 29
or (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))>>
  What for:   normalization of [serial 1023]

. . . done Normalizing Unsolved Proof Obligations [11.2 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1025]: WLCS::Controller.impl
P [94] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
S [94]->
Q [94] <<sw <= 30
or sw <= 29
or (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))>>
  What for:   normalization of [serial 1023]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [11.2 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [11.2 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1025]: WLCS::Controller.impl
P [94] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
S [94]->
Q [94] <<sw <= 30
or sw <= 29
or (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))>>
Reason:  Or Introduction Schema (orcwl):  X->(X or Y)
  What for:   normalization of [serial 1023]

Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)
. . . done Applying Axioms [11.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1007]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]cc!(Off)
;
<<TURN_OFF()>>
cv := Off
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(START) and x>> A <<M(DRAIN)>> for T0_start:START-[x]->DRAIN{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1007]  <<M(START) and x>> A <<M(DRAIN)>> for T0_start:START-[x]->DRAIN{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [11.2 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1007]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]cc!(Off)
;
<<TURN_OFF()>>
cv := Off
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(START) and x>> A <<M(DRAIN)>> for T0_start:START-[x]->DRAIN{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1028]: WLCS::Controller.impl
P [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1007]


[serial 1029]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]cc!(Off)
Q [99] <<TURN_OFF()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1007]


[serial 1030]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]cv := Off
Q [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1007]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1028]: WLCS::Controller.impl
P [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1007]



[serial 1029]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]cc!(Off)
Q [99] <<TURN_OFF()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1007]



[serial 1030]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]cv := Off
Q [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1007]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1028]: WLCS::Controller.impl
P [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1007]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [11.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1029]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]cc!(Off)
Q [99] <<TURN_OFF()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1007]



[serial 1030]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]cv := Off
Q [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1007]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1029]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]cc!(Off)
Q [99] <<TURN_OFF()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1007]

Has applied <<pre and (cc=Off)@now>> -> <<post>> for  <<pre>> cc!(Off) <<post>> to get:

[serial 1031]: WLCS::Controller.impl
P [99] <<((cv = Off) and (sw >= 60))
  and
  (cc = Off)@now>>
S [99]->
Q [99] <<TURN_OFF()>>
  What for: applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1029]

Has applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>>where (TURN_OFF()) -> Off for cc!(Off) to get:

[serial 1032]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]->
Q [73] <<(TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1029]

solving assignment on line 99
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
replacing "cv" with "Off"
makes:  <<Off = Off and (TURN_OFF() or STAY_SAME())>>

This Proof Obligation:

[serial 1030]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]cv := Off
Q [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1007]

Has applied := to get:

[serial 1033]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]->
Q [99] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1030]

. . . done applying atomic actions [11.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1031]: WLCS::Controller.impl
P [99] <<((cv = Off) and (sw >= 60))
  and
  (cc = Off)@now>>
S [99]->
Q [99] <<TURN_OFF()>>
  What for: applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1029]



[serial 1032]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]->
Q [73] <<(TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1029]



[serial 1033]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]->
Q [99] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1030]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1031]: WLCS::Controller.impl
P [99] <<((cv = Off) and (sw >= 60))
  and
  (cc = Off)@now>>
S [99]->
Q [99] <<TURN_OFF()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1029]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1034]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<TURN_OFF()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1031]

. . . done replacing P@now and P^0 with P  [11.3 seconds ]
After assuming present remaining 
Obligations:

[serial 1032]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]->
Q [73] <<(TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1029]



[serial 1033]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]->
Q [99] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1030]



[serial 1034]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<TURN_OFF()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1031]


Done assuming present.
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1032]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]->
Q [73] <<(TURN_OFF())>>
Reason:  Substitution of Assertion Labels
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1029]

Has substituted Assertions' predicates for labels to get:

[serial 1035]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]->
Q [73] <<((sw >= 60))>>
  What for: substituted Assertions' predicates for  labels  [serial 1032]


This Proof Obligation:

[serial 1033]: WLCS::Controller.impl
P [99] <<TURN_OFF()>>
S [99]->
Q [99] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Substitution of Assertion Labels
  What for: applied wp for assignment [serial 1030]

Has substituted Assertions' predicates for labels to get:

[serial 1036]: WLCS::Controller.impl
P [99] <<(sw >= 60)>>
S [99]->
Q [99] <<Off = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))>>
  What for: substituted Assertions' predicates for  labels  [serial 1033]


This Proof Obligation:

[serial 1034]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<TURN_OFF()>>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 1031]

Has substituted Assertions' predicates for labels to get:

[serial 1037]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<(sw >= 60)>>
  What for: substituted Assertions' predicates for  labels  [serial 1034]

. . . done Substituting Assertions for Labels [11.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1035]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw >= 60)>>
S [99]->
Q [73] <<((sw >= 60))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1032]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1039]: WLCS::Controller.impl
P [90] <<60 <= sw and Off = cv>>
S [99]->
Q [73] <<60 <= sw>>
  What for:   normalization of [serial 1035]


This Proof Obligation:

[serial 1036]: WLCS::Controller.impl
P [99] <<(sw >= 60)>>
S [99]->
Q [99] <<Off = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1033]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1041]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1036]


This Proof Obligation:

[serial 1037]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<(sw >= 60)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1034]

  Normalization Axioms:

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1043]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<60 <= sw>>
  What for:   normalization of [serial 1037]

. . . done Normalizing Unsolved Proof Obligations [11.3 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1039]: WLCS::Controller.impl
P [90] <<60 <= sw and Off = cv>>
S [99]->
Q [73] <<60 <= sw>>
  What for:   normalization of [serial 1035]



[serial 1041]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1036]



[serial 1043]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<60 <= sw>>
  What for:   normalization of [serial 1037]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [11.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [11.3 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1039]: WLCS::Controller.impl
P [90] <<60 <= sw and Off = cv>>
S [99]->
Q [73] <<60 <= sw>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1035]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [11.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1041]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1036]



[serial 1043]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<60 <= sw>>
  What for:   normalization of [serial 1037]


Done trying to apply axioms
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1041]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1036]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1050]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<true and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Equality Law (idistr):  a=a <-> true [serial 1041]


This Proof Obligation:

[serial 1043]: WLCS::Controller.impl
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99]->
Q [99] <<60 <= sw>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1037]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1051]: WLCS::Controller.impl
P [99] <<60 <= sw and Off = cv and Off = cc>>
S [99]->
Q [99] <<60 <= sw>>
  What for: Associativity: (b.c).a = a.b.c [serial 1043]


This Proof Obligation:

[serial 1050]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<true and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1041]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1052]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
  What for: Law of And-Simplification:  P and true is P [serial 1050]

. . . done Applying Laws [11.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1051]: WLCS::Controller.impl
P [99] <<60 <= sw and Off = cv and Off = cc>>
S [99]->
Q [99] <<60 <= sw>>
  What for: Associativity: (b.c).a = a.b.c [serial 1043]



[serial 1052]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
  What for: Law of And-Simplification:  P and true is P [serial 1050]


Done applying laws
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1051]: WLCS::Controller.impl
P [99] <<60 <= sw and Off = cv and Off = cc>>
S [99]->
Q [99] <<60 <= sw>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 1043]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [11.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1052]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
  What for: Law of And-Simplification:  P and true is P [serial 1050]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1052]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1050]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1054]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1052]

. . . done Normalizing Unsolved Proof Obligations [11.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1054]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1052]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1054]: WLCS::Controller.impl
P [99] <<60 <= sw>>
S [99]->
Q [99] <<60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  Or Introduction Schema (orcwl):  X->(X or Y)
  What for:   normalization of [serial 1052]

Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)
. . . done Applying Axioms [11.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1008]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]cc!(On)
;
<<TURN_ON()>>
cv := On
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for:  <<M(START) and x>> A <<M(FILL)>> for T1_start:START-[x]->FILL{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1008]  <<M(START) and x>> A <<M(FILL)>> for T1_start:START-[x]->FILL{A};
****reduce****
This proof obligation:

[serial 1008]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]cc!(On)
;
<<TURN_ON()>>
cv := On
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for:  <<M(START) and x>> A <<M(FILL)>> for T1_start:START-[x]->FILL{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1056]: WLCS::Controller.impl
P [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1008]


[serial 1057]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]cc!(On)
Q [100] <<TURN_ON()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1008]


[serial 1058]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]cv := On
Q [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1008]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1056]: WLCS::Controller.impl
P [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1008]



[serial 1057]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]cc!(On)
Q [100] <<TURN_ON()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1008]



[serial 1058]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]cv := On
Q [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1008]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1056]: WLCS::Controller.impl
P [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1008]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [11.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1057]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]cc!(On)
Q [100] <<TURN_ON()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1008]



[serial 1058]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]cv := On
Q [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1008]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1057]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]cc!(On)
Q [100] <<TURN_ON()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1008]

Has applied <<pre and (cc=On)@now>> -> <<post>> for  <<pre>> cc!(On) <<post>> to get:

[serial 1059]: WLCS::Controller.impl
P [100] <<((cv = Off) and (sw <= 30))
  and
  (cc = On)@now>>
S [100]->
Q [100] <<TURN_ON()>>
  What for: applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1057]

Has applied port output of conditional expression <<pre>> -> <<(TURN_ON())>>where (TURN_ON()) -> On for cc!(On) to get:

[serial 1060]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]->
Q [74] <<(TURN_ON())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1057]

solving assignment on line 100
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
replacing "cv" with "On"
makes:  <<On = On and (TURN_ON() or STAY_SAME())>>

This Proof Obligation:

[serial 1058]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]cv := On
Q [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1008]

Has applied := to get:

[serial 1061]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<On = On and (TURN_ON() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1058]

. . . done applying atomic actions [11.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1059]: WLCS::Controller.impl
P [100] <<((cv = Off) and (sw <= 30))
  and
  (cc = On)@now>>
S [100]->
Q [100] <<TURN_ON()>>
  What for: applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1057]



[serial 1060]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]->
Q [74] <<(TURN_ON())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1057]



[serial 1061]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<On = On and (TURN_ON() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1058]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1059]: WLCS::Controller.impl
P [100] <<((cv = Off) and (sw <= 30))
  and
  (cc = On)@now>>
S [100]->
Q [100] <<TURN_ON()>>
Reason:  Normalization
  What for: applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1057]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1063]: WLCS::Controller.impl
P [100] <<(On = cc)@now and (sw <= 30 and Off = cv)>>
S [100]->
Q [100] <<TURN_ON()>>
  What for:   normalization of [serial 1059]


This Proof Obligation:

[serial 1060]: WLCS::Controller.impl
P [90] <<(cv = Off) and (sw <= 30)>>
S [100]->
Q [74] <<(TURN_ON())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1057]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1060]


This Proof Obligation:

[serial 1061]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<On = On and (TURN_ON() or STAY_SAME())>>
Reason:  Normalization
  What for: applied wp for assignment [serial 1058]

  Normalization Axiom:

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1067]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<On = On and (STAY_SAME() or TURN_ON())>>
  What for:   normalization of [serial 1061]

. . . done Normalizing Unsolved Proof Obligations [11.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1063]: WLCS::Controller.impl
P [100] <<(On = cc)@now and (sw <= 30 and Off = cv)>>
S [100]->
Q [100] <<TURN_ON()>>
  What for:   normalization of [serial 1059]



[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1060]



[serial 1067]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<On = On and (STAY_SAME() or TURN_ON())>>
  What for:   normalization of [serial 1061]


Done Normalizing
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1063]: WLCS::Controller.impl
P [100] <<(On = cc)@now and (sw <= 30 and Off = cv)>>
S [100]->
Q [100] <<TURN_ON()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1059]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1071]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and (On = cc)@now>>
S [100]->
Q [100] <<TURN_ON()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1063]


This Proof Obligation:

[serial 1067]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<On = On and (STAY_SAME() or TURN_ON())>>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1061]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1072]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<true and (STAY_SAME() or TURN_ON())>>
  What for: Equality Law (idistr):  a=a <-> true [serial 1067]


This Proof Obligation:

[serial 1072]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<true and (STAY_SAME() or TURN_ON())>>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1067]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1073]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<((STAY_SAME() or TURN_ON()))>>
  What for: Law of And-Simplification:  P and true is P [serial 1072]

. . . done Applying Laws [11.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1060]



[serial 1071]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and (On = cc)@now>>
S [100]->
Q [100] <<TURN_ON()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1063]



[serial 1073]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<((STAY_SAME() or TURN_ON()))>>
  What for: Law of And-Simplification:  P and true is P [serial 1072]


Done applying laws
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1071]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and (On = cc)@now>>
S [100]->
Q [100] <<TURN_ON()>>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1063]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1076]: WLCS::Controller.impl
P [100] <<sw <= 30 and (On = cc)@now and Off = cv>>
S [100]->
Q [100] <<TURN_ON()>>
  What for:   normalization of [serial 1071]


This Proof Obligation:

[serial 1073]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<((STAY_SAME() or TURN_ON()))>>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1072]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1078]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<STAY_SAME() or TURN_ON()>>
  What for:   normalization of [serial 1073]

. . . done Normalizing Unsolved Proof Obligations [11.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1060]



[serial 1076]: WLCS::Controller.impl
P [100] <<sw <= 30 and (On = cc)@now and Off = cv>>
S [100]->
Q [100] <<TURN_ON()>>
  What for:   normalization of [serial 1071]



[serial 1078]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<STAY_SAME() or TURN_ON()>>
  What for:   normalization of [serial 1073]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1078]: WLCS::Controller.impl
P [100] <<TURN_ON()>>
S [100]->
Q [100] <<STAY_SAME() or TURN_ON()>>
Reason:  Or Introduction Schema (orcwl):  X->(X or Y)
  What for:   normalization of [serial 1073]

Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)
. . . done Applying Axioms [11.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1060]



[serial 1076]: WLCS::Controller.impl
P [100] <<sw <= 30 and (On = cc)@now and Off = cv>>
S [100]->
Q [100] <<TURN_ON()>>
  What for:   normalization of [serial 1071]


Done trying to apply axioms
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1076]: WLCS::Controller.impl
P [100] <<sw <= 30 and (On = cc)@now and Off = cv>>
S [100]->
Q [100] <<TURN_ON()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for:   normalization of [serial 1071]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1081]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<TURN_ON()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1076]

. . . done replacing P@now and P^0 with P  [11.6 seconds ]
After assuming present remaining 
Obligations:

[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1060]



[serial 1081]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<TURN_ON()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1076]


Done assuming present.
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1065]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<TURN_ON()>>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1060]

Has substituted Assertions' predicates for labels to get:

[serial 1082]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<(sw <= 30)>>
  What for: substituted Assertions' predicates for  labels  [serial 1065]


This Proof Obligation:

[serial 1081]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<TURN_ON()>>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 1076]

Has substituted Assertions' predicates for labels to get:

[serial 1083]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<(sw <= 30)>>
  What for: substituted Assertions' predicates for  labels  [serial 1081]

. . . done Substituting Assertions for Labels [11.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1082]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<(sw <= 30)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1065]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1085]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<sw <= 30>>
  What for:   normalization of [serial 1082]


This Proof Obligation:

[serial 1083]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<(sw <= 30)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1081]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1087]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<sw <= 30>>
  What for:   normalization of [serial 1083]

. . . done Normalizing Unsolved Proof Obligations [11.6 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1085]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<sw <= 30>>
  What for:   normalization of [serial 1082]



[serial 1087]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<sw <= 30>>
  What for:   normalization of [serial 1083]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [11.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [11.6 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1085]: WLCS::Controller.impl
P [90] <<sw <= 30 and Off = cv>>
S [100]->
Q [74] <<sw <= 30>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1082]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1087]: WLCS::Controller.impl
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100]->
Q [100] <<sw <= 30>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1083]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [11.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1009]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]cc!(nc)
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(START) and x>> A <<M(DRAIN)>> for T2_start:START-[x]->DRAIN{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1009]  <<M(START) and x>> A <<M(DRAIN)>> for T2_start:START-[x]->DRAIN{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [11.6 seconds ]
After applying axioms, no change 
****reduce****

[serial 1092]: WLCS::Controller.impl
P [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]


[serial 1093]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]cc!(nc)
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1092]: WLCS::Controller.impl
P [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]



[serial 1093]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]cc!(nc)
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1092]: WLCS::Controller.impl
P [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [11.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1093]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]cc!(nc)
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1093]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]cc!(nc)
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]

Has applied <<pre and (cc=nc)@now>> -> <<post>> for  <<pre>> cc!(nc) <<post>> to get:

[serial 1094]: WLCS::Controller.impl
P [101] <<((cv = Off) and ((sw > 30) and (sw < 60)))
  and
  (cc = nc)@now>>
S [101]->
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1093]

Has applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) to get:

[serial 1095]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1093]

. . . done applying atomic actions [11.6 seconds ]
After "atomic" remaining 
Obligations:

[serial 1094]: WLCS::Controller.impl
P [101] <<((cv = Off) and ((sw > 30) and (sw < 60)))
  and
  (cc = nc)@now>>
S [101]->
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1093]



[serial 1095]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1093]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1094]: WLCS::Controller.impl
P [101] <<((cv = Off) and ((sw > 30) and (sw < 60)))
  and
  (cc = nc)@now>>
S [101]->
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1093]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1096]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1094]

. . . done replacing P@now and P^0 with P  [11.6 seconds ]
After assuming present remaining 
Obligations:

[serial 1095]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1093]



[serial 1096]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1094]


Done assuming present.
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1095]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
Reason:  Substitution of Assertion Labels
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1093]

Has substituted Assertions' predicates for labels to get:

[serial 1097]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]->
Q [72] <<(((sw > 30) and (sw < 60))
or (sw <= 30)
or (sw >= 60))>>
  What for: substituted Assertions' predicates for  labels  [serial 1095]


This Proof Obligation:

[serial 1096]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 1094]

Has substituted Assertions' predicates for labels to get:

[serial 1098]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
  What for: substituted Assertions' predicates for  labels  [serial 1096]

. . . done Substituting Assertions for Labels [11.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1097]: WLCS::Controller.impl
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101]->
Q [72] <<(((sw > 30) and (sw < 60))
or (sw <= 30)
or (sw >= 60))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1095]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1100]: WLCS::Controller.impl
P [90] <<Off = cv and (sw < 60 and 30 < sw)>>
S [101]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1097]


This Proof Obligation:

[serial 1098]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1096]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1102]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1098]

. . . done Normalizing Unsolved Proof Obligations [11.7 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1100]: WLCS::Controller.impl
P [90] <<Off = cv and (sw < 60 and 30 < sw)>>
S [101]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1097]



[serial 1102]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1098]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [11.7 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [11.7 seconds ]
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1100]: WLCS::Controller.impl
P [90] <<Off = cv and (sw < 60 and 30 < sw)>>
S [101]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1097]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1107]: WLCS::Controller.impl
P [90] <<sw < 60 and 30 < sw and Off = cv>>
S [101]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for: Associativity: (b.c).a = a.b.c [serial 1100]


This Proof Obligation:

[serial 1102]: WLCS::Controller.impl
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1098]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1108]: WLCS::Controller.impl
P [101] <<Off = cv and (sw < 60 and 30 < sw) and cc = nc>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1102]


This Proof Obligation:

[serial 1108]: WLCS::Controller.impl
P [101] <<Off = cv and (sw < 60 and 30 < sw) and cc = nc>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Associativity: (b.c).a = a.b.c [serial 1102]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1109]: WLCS::Controller.impl
P [101] <<sw < 60 and 30 < sw and Off = cv and cc = nc>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1108]

. . . done Applying Laws [11.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1107]: WLCS::Controller.impl
P [90] <<sw < 60 and 30 < sw and Off = cv>>
S [101]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for: Associativity: (b.c).a = a.b.c [serial 1100]



[serial 1109]: WLCS::Controller.impl
P [101] <<sw < 60 and 30 < sw and Off = cv and cc = nc>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1108]


Done applying laws
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 sw < 60 and 30 < sw


This Proof Obligation:

[serial 1107]: WLCS::Controller.impl
P [90] <<sw < 60 and 30 < sw and Off = cv>>
S [101]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
  What for: Associativity: (b.c).a = a.b.c [serial 1100]

Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [11.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1109]: WLCS::Controller.impl
P [101] <<sw < 60 and 30 < sw and Off = cv and cc = nc>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1108]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1109]: WLCS::Controller.impl
P [101] <<sw < 60 and 30 < sw and Off = cv and cc = nc>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1108]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1111]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1109]

. . . done Normalizing Unsolved Proof Obligations [11.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1111]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1109]


Done Normalizing
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1111]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1109]

Has split postcondition to get:

[serial 1113]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<Off = cv>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]


[serial 1114]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<(60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]

. . . done splitting postcondition  [11.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1113]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<Off = cv>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]



[serial 1114]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<(60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]


Done splitting postcondition
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1113]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<Off = cv>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [11.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1114]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<(60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]


Done trying to apply axioms
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1114]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<(60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1116]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1114]

. . . done Normalizing Unsolved Proof Obligations [11.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1116]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1114]


Done Normalizing
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 sw < 60 and 30 < sw


This Proof Obligation:

[serial 1116]: WLCS::Controller.impl
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101]->
Q [101] <<60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
  What for:   normalization of [serial 1114]

Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [11.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1010]: WLCS::Controller.impl
P [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [103]->
Q [93] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for:  <<M(FILL) and x>> -> <<M(CHECK_FILL)>> for T3_check_fill:FILL-[x]->CHECK_FILL{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1010]  <<M(FILL) and x>> -> <<M(CHECK_FILL)>> for T3_check_fill:FILL-[x]->CHECK_FILL{};
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1010]: WLCS::Controller.impl
P [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [103]->
Q [93] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for:  <<M(FILL) and x>> -> <<M(CHECK_FILL)>> for T3_check_fill:FILL-[x]->CHECK_FILL{};

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [11.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1011]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]cc!(nc)
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for:  <<M(CHECK_FILL) and x>> A <<M(FILL)>> for T4_fill_ok:CHECK_FILL-[x]->FILL{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1011]  <<M(CHECK_FILL) and x>> A <<M(FILL)>> for T4_fill_ok:CHECK_FILL-[x]->FILL{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [11.8 seconds ]
After applying axioms, no change 
****reduce****

[serial 1118]: WLCS::Controller.impl
P [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]


[serial 1119]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]cc!(nc)
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1118]: WLCS::Controller.impl
P [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]



[serial 1119]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]cc!(nc)
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1118]: WLCS::Controller.impl
P [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [11.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1119]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]cc!(nc)
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1119]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]cc!(nc)
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]

Has applied <<pre and (cc=nc)@now>> -> <<post>> for  <<pre>> cc!(nc) <<post>> to get:

[serial 1120]: WLCS::Controller.impl
P [104] <<(cv = On
    and
    (TURN_ON() or STAY_SAME())
    and
    ((cv = On)
      and
      (((sw > 30) and (sw < 60)) or (sw <= 30))))
  and
  (cc = nc)@now>>
S [104]->
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1119]

Has applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) to get:

[serial 1121]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1119]

. . . done applying atomic actions [11.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1120]: WLCS::Controller.impl
P [104] <<(cv = On
    and
    (TURN_ON() or STAY_SAME())
    and
    ((cv = On)
      and
      (((sw > 30) and (sw < 60)) or (sw <= 30))))
  and
  (cc = nc)@now>>
S [104]->
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1119]



[serial 1121]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1119]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1120]: WLCS::Controller.impl
P [104] <<(cv = On
    and
    (TURN_ON() or STAY_SAME())
    and
    ((cv = On)
      and
      (((sw > 30) and (sw < 60)) or (sw <= 30))))
  and
  (cc = nc)@now>>
S [104]->
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1119]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1122]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_ON()))>>
S [104]->
Q [104] <<On = cv and (STAY_SAME() or TURN_ON())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1120]

. . . done replacing P@now and P^0 with P  [11.9 seconds ]
After assuming present remaining 
Obligations:

[serial 1121]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1119]



[serial 1122]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_ON()))>>
S [104]->
Q [104] <<On = cv and (STAY_SAME() or TURN_ON())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1120]


Done assuming present.
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1121]: WLCS::Controller.impl
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
Reason:  Substitution of Assertion Labels
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1119]

Has substituted Assertions' predicates for labels to get:

[serial 1123]: WLCS::Controller.impl
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [72] <<(((sw > 30) and (sw < 60))
or (sw <= 30)
or (sw >= 60))>>
  What for: substituted Assertions' predicates for  labels  [serial 1121]


This Proof Obligation:

[serial 1122]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_ON()))>>
S [104]->
Q [104] <<On = cv and (STAY_SAME() or TURN_ON())>>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 1120]

Has substituted Assertions' predicates for labels to get:

[serial 1124]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [104] <<On = cv
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30))>>
  What for: substituted Assertions' predicates for  labels  [serial 1122]

. . . done Substituting Assertions for Labels [11.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1123]: WLCS::Controller.impl
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [72] <<(((sw > 30) and (sw < 60))
or (sw <= 30)
or (sw >= 60))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1121]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1126]: WLCS::Controller.impl
P [93] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1123]


This Proof Obligation:

[serial 1124]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104]->
Q [104] <<On = cv
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1122]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1128]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1124]

. . . done Normalizing Unsolved Proof Obligations [11.9 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1126]: WLCS::Controller.impl
P [93] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1123]



[serial 1128]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1124]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [12.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [12.0 seconds ]
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1126]: WLCS::Controller.impl
P [93] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1123]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1133]: WLCS::Controller.impl
P [93] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for: Associativity: (b.c).a = a.b.c [serial 1126]


This Proof Obligation:

[serial 1128]: WLCS::Controller.impl
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1124]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1134]: WLCS::Controller.impl
P [104] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1128]


This Proof Obligation:

[serial 1134]: WLCS::Controller.impl
P [104] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Associativity: (b.c).a = a.b.c [serial 1128]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1135]: WLCS::Controller.impl
P [104] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1134]

. . . done Applying Laws [12.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1133]: WLCS::Controller.impl
P [93] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
  What for: Associativity: (b.c).a = a.b.c [serial 1126]



[serial 1135]: WLCS::Controller.impl
P [104] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1134]


Done applying laws
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 (sw <= 30 or (sw < 60 and 30 < sw))


This Proof Obligation:

[serial 1133]: WLCS::Controller.impl
P [93] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104]->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for: Associativity: (b.c).a = a.b.c [serial 1126]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1135]: WLCS::Controller.impl
P [104] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104]->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1134]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [12.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1012]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]cc!(Off)
;
<<TURN_OFF()>>
cv := Off
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(CHECK_FILL) and x>> A <<M(DRAIN)>> for T5_fill_out:CHECK_FILL-[x]->DRAIN{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1012]  <<M(CHECK_FILL) and x>> A <<M(DRAIN)>> for T5_fill_out:CHECK_FILL-[x]->DRAIN{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [12.0 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1012]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]cc!(Off)
;
<<TURN_OFF()>>
cv := Off
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(CHECK_FILL) and x>> A <<M(DRAIN)>> for T5_fill_out:CHECK_FILL-[x]->DRAIN{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1136]: WLCS::Controller.impl
P [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1012]


[serial 1137]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]cc!(Off)
Q [105] <<TURN_OFF()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]


[serial 1138]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]cv := Off
Q [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1136]: WLCS::Controller.impl
P [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1012]



[serial 1137]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]cc!(Off)
Q [105] <<TURN_OFF()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]



[serial 1138]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]cv := Off
Q [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1136]: WLCS::Controller.impl
P [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1012]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [12.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1137]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]cc!(Off)
Q [105] <<TURN_OFF()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]



[serial 1138]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]cv := Off
Q [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1137]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]cc!(Off)
Q [105] <<TURN_OFF()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]

Has applied <<pre and (cc=Off)@now>> -> <<post>> for  <<pre>> cc!(Off) <<post>> to get:

[serial 1139]: WLCS::Controller.impl
P [105] <<(cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60))
  and
  (cc = Off)@now>>
S [105]->
Q [105] <<TURN_OFF()>>
  What for: applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1137]

Has applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>>where (TURN_OFF()) -> Off for cc!(Off) to get:

[serial 1140]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]->
Q [73] <<(TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1137]

solving assignment on line 105
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
replacing "cv" with "Off"
makes:  <<Off = Off and (TURN_OFF() or STAY_SAME())>>

This Proof Obligation:

[serial 1138]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]cv := Off
Q [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]

Has applied := to get:

[serial 1141]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1138]

. . . done applying atomic actions [12.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1139]: WLCS::Controller.impl
P [105] <<(cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60))
  and
  (cc = Off)@now>>
S [105]->
Q [105] <<TURN_OFF()>>
  What for: applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1137]



[serial 1140]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]->
Q [73] <<(TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1137]



[serial 1141]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1138]


Done reducing atomic actions
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1139]: WLCS::Controller.impl
P [105] <<(cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60))
  and
  (cc = Off)@now>>
S [105]->
Q [105] <<TURN_OFF()>>
Reason:  Normalization
  What for: applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1137]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1143]: WLCS::Controller.impl
P [105] <<(Off = cc)@now
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105]->
Q [105] <<TURN_OFF()>>
  What for:   normalization of [serial 1139]


This Proof Obligation:

[serial 1140]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105]->
Q [73] <<(TURN_OFF())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1137]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1145]: WLCS::Controller.impl
P [93] <<60 <= sw and On = cv and (STAY_SAME() or TURN_ON())>>
S [105]->
Q [73] <<TURN_OFF()>>
  What for:   normalization of [serial 1140]


This Proof Obligation:

[serial 1141]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Normalization
  What for: applied wp for assignment [serial 1138]

  Normalization Axiom:

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1147]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (STAY_SAME() or TURN_OFF())>>
  What for:   normalization of [serial 1141]

. . . done Normalizing Unsolved Proof Obligations [12.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1143]: WLCS::Controller.impl
P [105] <<(Off = cc)@now
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105]->
Q [105] <<TURN_OFF()>>
  What for:   normalization of [serial 1139]



[serial 1145]: WLCS::Controller.impl
P [93] <<60 <= sw and On = cv and (STAY_SAME() or TURN_ON())>>
S [105]->
Q [73] <<TURN_OFF()>>
  What for:   normalization of [serial 1140]



[serial 1147]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (STAY_SAME() or TURN_OFF())>>
  What for:   normalization of [serial 1141]


Done Normalizing
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1143]: WLCS::Controller.impl
P [105] <<(Off = cc)@now
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105]->
Q [105] <<TURN_OFF()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for:   normalization of [serial 1139]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1151]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105]->
Q [105] <<TURN_OFF()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1143]

. . . done replacing P@now and P^0 with P  [12.1 seconds ]
After assuming present remaining 
Obligations:

[serial 1145]: WLCS::Controller.impl
P [93] <<60 <= sw and On = cv and (STAY_SAME() or TURN_ON())>>
S [105]->
Q [73] <<TURN_OFF()>>
  What for:   normalization of [serial 1140]



[serial 1147]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (STAY_SAME() or TURN_OFF())>>
  What for:   normalization of [serial 1141]



[serial 1151]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105]->
Q [105] <<TURN_OFF()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1143]


Done assuming present.
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1145]: WLCS::Controller.impl
P [93] <<60 <= sw and On = cv and (STAY_SAME() or TURN_ON())>>
S [105]->
Q [73] <<TURN_OFF()>>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1140]

Has substituted Assertions' predicates for labels to get:

[serial 1152]: WLCS::Controller.impl
P [93] <<60 <= sw
  and
  On = cv
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30))>>
S [105]->
Q [73] <<(sw >= 60)>>
  What for: substituted Assertions' predicates for  labels  [serial 1145]


This Proof Obligation:

[serial 1147]: WLCS::Controller.impl
P [105] <<TURN_OFF()>>
S [105]->
Q [105] <<Off = Off and (STAY_SAME() or TURN_OFF())>>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1141]

Has substituted Assertions' predicates for labels to get:

[serial 1153]: WLCS::Controller.impl
P [105] <<(sw >= 60)>>
S [105]->
Q [105] <<Off = Off
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
  What for: substituted Assertions' predicates for  labels  [serial 1147]


This Proof Obligation:

[serial 1151]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105]->
Q [105] <<TURN_OFF()>>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 1143]

Has substituted Assertions' predicates for labels to get:

[serial 1154]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [105]->
Q [105] <<(sw >= 60)>>
  What for: substituted Assertions' predicates for  labels  [serial 1151]

. . . done Substituting Assertions for Labels [12.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1152]: WLCS::Controller.impl
P [93] <<60 <= sw
  and
  On = cv
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30))>>
S [105]->
Q [73] <<(sw >= 60)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1145]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1156]: WLCS::Controller.impl
P [93] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105]->
Q [73] <<60 <= sw>>
  What for:   normalization of [serial 1152]


This Proof Obligation:

[serial 1153]: WLCS::Controller.impl
P [105] <<(sw >= 60)>>
S [105]->
Q [105] <<Off = Off
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1147]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1158]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1153]


This Proof Obligation:

[serial 1154]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [105]->
Q [105] <<(sw >= 60)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1151]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1160]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [105]->
Q [105] <<60 <= sw>>
  What for:   normalization of [serial 1154]

. . . done Normalizing Unsolved Proof Obligations [12.2 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1156]: WLCS::Controller.impl
P [93] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105]->
Q [73] <<60 <= sw>>
  What for:   normalization of [serial 1152]



[serial 1158]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1153]



[serial 1160]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [105]->
Q [105] <<60 <= sw>>
  What for:   normalization of [serial 1154]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [12.2 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [12.2 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1156]: WLCS::Controller.impl
P [93] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105]->
Q [73] <<60 <= sw>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1152]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1158]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1153]



[serial 1160]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [105]->
Q [105] <<60 <= sw>>
  What for:   normalization of [serial 1154]


Done trying to apply axioms
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1158]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1153]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1167]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<true and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Equality Law (idistr):  a=a <-> true [serial 1158]


This Proof Obligation:

[serial 1160]: WLCS::Controller.impl
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [105]->
Q [105] <<60 <= sw>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1154]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1168]: WLCS::Controller.impl
P [105] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  Off = cc>>
S [105]->
Q [105] <<60 <= sw>>
  What for: Associativity: (b.c).a = a.b.c [serial 1160]


This Proof Obligation:

[serial 1167]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<true and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1158]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1169]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
  What for: Law of And-Simplification:  P and true is P [serial 1167]

. . . done Applying Laws [12.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1168]: WLCS::Controller.impl
P [105] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  Off = cc>>
S [105]->
Q [105] <<60 <= sw>>
  What for: Associativity: (b.c).a = a.b.c [serial 1160]



[serial 1169]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
  What for: Law of And-Simplification:  P and true is P [serial 1167]


Done applying laws
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1168]: WLCS::Controller.impl
P [105] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  Off = cc>>
S [105]->
Q [105] <<60 <= sw>>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1160]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1171]: WLCS::Controller.impl
P [105] <<60 <= sw
  and
  Off = cc
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105]->
Q [105] <<60 <= sw>>
  What for:   normalization of [serial 1168]


This Proof Obligation:

[serial 1169]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1167]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1173]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1169]

. . . done Normalizing Unsolved Proof Obligations [12.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1171]: WLCS::Controller.impl
P [105] <<60 <= sw
  and
  Off = cc
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105]->
Q [105] <<60 <= sw>>
  What for:   normalization of [serial 1168]



[serial 1173]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<60 <= sw or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1169]


Done Normalizing
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1171]: WLCS::Controller.impl
P [105] <<60 <= sw
  and
  Off = cc
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105]->
Q [105] <<60 <= sw>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1168]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1173]: WLCS::Controller.impl
P [105] <<60 <= sw>>
S [105]->
Q [105] <<60 <= sw or (sw < 60 and 30 < sw)>>
Reason:  Or Introduction Schema (orcwl):  X->(X or Y)
  What for:   normalization of [serial 1169]

Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)
. . . done Applying Axioms [12.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1013]: WLCS::Controller.impl
P [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [107]->
Q [94] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(DRAIN) and x>> -> <<M(CHECK_DRAIN)>> for T6_check_drain:DRAIN-[x]->CHECK_DRAIN{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1013]  <<M(DRAIN) and x>> -> <<M(CHECK_DRAIN)>> for T6_check_drain:DRAIN-[x]->CHECK_DRAIN{};
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1013]: WLCS::Controller.impl
P [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [107]->
Q [94] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for:  <<M(DRAIN) and x>> -> <<M(CHECK_DRAIN)>> for T6_check_drain:DRAIN-[x]->CHECK_DRAIN{};

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [12.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1014]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]cc!(nc)
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for:  <<M(CHECK_DRAIN) and x>> A <<M(DRAIN)>> for T7_drain_ok:CHECK_DRAIN-[x]->DRAIN{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [12.2 seconds ]
After applying axioms, no change 
#[serial 1014]  <<M(CHECK_DRAIN) and x>> A <<M(DRAIN)>> for T7_drain_ok:CHECK_DRAIN-[x]->DRAIN{A};
****reduce****

[serial 1176]: WLCS::Controller.impl
P [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]


[serial 1177]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]cc!(nc)
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1176]: WLCS::Controller.impl
P [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]



[serial 1177]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]cc!(nc)
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1176]: WLCS::Controller.impl
P [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92]->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [12.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1177]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]cc!(nc)
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1177]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]cc!(nc)
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]

Has applied <<pre and (cc=nc)@now>> -> <<post>> for  <<pre>> cc!(nc) <<post>> to get:

[serial 1178]: WLCS::Controller.impl
P [108] <<(cv = Off
    and
    (TURN_OFF() or STAY_SAME())
    and
    ((cv = Off)
      and
      (((sw > 30) and (sw < 60)) or (sw >= 60))))
  and
  (cc = nc)@now>>
S [108]->
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1177]

Has applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) to get:

[serial 1179]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1177]

. . . done applying atomic actions [12.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1178]: WLCS::Controller.impl
P [108] <<(cv = Off
    and
    (TURN_OFF() or STAY_SAME())
    and
    ((cv = Off)
      and
      (((sw > 30) and (sw < 60)) or (sw >= 60))))
  and
  (cc = nc)@now>>
S [108]->
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1177]



[serial 1179]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1177]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1178]: WLCS::Controller.impl
P [108] <<(cv = Off
    and
    (TURN_OFF() or STAY_SAME())
    and
    ((cv = Off)
      and
      (((sw > 30) and (sw < 60)) or (sw >= 60))))
  and
  (cc = nc)@now>>
S [108]->
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1177]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1180]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_OFF()))>>
S [108]->
Q [108] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1178]

. . . done replacing P@now and P^0 with P  [12.3 seconds ]
After assuming present remaining 
Obligations:

[serial 1179]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1177]



[serial 1180]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_OFF()))>>
S [108]->
Q [108] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1178]


Done assuming present.
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1179]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1177]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1182]: WLCS::Controller.impl
P [94] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (STAY_SAME() or TURN_OFF())>>
S [108]->
Q [72] <<STAY_SAME() or TURN_OFF() or TURN_ON()>>
  What for:   normalization of [serial 1179]

. . . done Normalizing Unsolved Proof Obligations [12.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1180]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_OFF()))>>
S [108]->
Q [108] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1178]



[serial 1182]: WLCS::Controller.impl
P [94] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (STAY_SAME() or TURN_OFF())>>
S [108]->
Q [72] <<STAY_SAME() or TURN_OFF() or TURN_ON()>>
  What for:   normalization of [serial 1179]


Done Normalizing
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 (STAY_SAME() or TURN_OFF())


This Proof Obligation:

[serial 1182]: WLCS::Controller.impl
P [94] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (STAY_SAME() or TURN_OFF())>>
S [108]->
Q [72] <<STAY_SAME() or TURN_OFF() or TURN_ON()>>
Reason:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
  What for:   normalization of [serial 1179]

Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [12.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1180]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_OFF()))>>
S [108]->
Q [108] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
  What for: Assume Present:  P = P@now = P^0  [serial 1178]


Done trying to apply axioms
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1180]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_OFF()))>>
S [108]->
Q [108] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 1178]

Has substituted Assertions' predicates for labels to get:

[serial 1185]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]->
Q [108] <<Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
  What for: substituted Assertions' predicates for  labels  [serial 1180]

. . . done Substituting Assertions for Labels [12.3 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1185]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108]->
Q [108] <<Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1180]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1187]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (60 <= sw or (sw < 60 and 30 < sw)))>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1185]

. . . done Normalizing Unsolved Proof Obligations [12.4 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1187]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (60 <= sw or (sw < 60 and 30 < sw)))>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for:   normalization of [serial 1185]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [12.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [12.4 seconds ]
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1187]: WLCS::Controller.impl
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (60 <= sw or (sw < 60 and 30 < sw)))>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1185]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1190]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1187]


This Proof Obligation:

[serial 1190]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Associativity: (b.c).a = a.b.c [serial 1187]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1191]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1190]

. . . done Applying Laws [12.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1191]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Associativity: (b.c).a = a.b.c [serial 1190]


Done applying laws
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1191]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Associativity: (b.c).a = a.b.c [serial 1190]

Has split postcondition to get:

[serial 1192]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]


[serial 1193]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<(60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]

. . . done splitting postcondition  [12.4 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1192]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]



[serial 1193]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<(60 <= sw or (sw < 60 and 30 < sw))>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]


Done splitting postcondition
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1192]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<Off = cv>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1193]: WLCS::Controller.impl
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108]->
Q [108] <<(60 <= sw or (sw < 60 and 30 < sw))>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1015]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]cc!(On)
;
<<TURN_ON()>>
cv := On
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for:  <<M(CHECK_DRAIN) and x>> A <<M(FILL)>> for T8_drain_out:CHECK_DRAIN-[x]->FILL{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1015]  <<M(CHECK_DRAIN) and x>> A <<M(FILL)>> for T8_drain_out:CHECK_DRAIN-[x]->FILL{A};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [12.4 seconds ]
After applying axioms, no change 
****reduce****
This proof obligation:

[serial 1015]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]cc!(On)
;
<<TURN_ON()>>
cv := On
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for:  <<M(CHECK_DRAIN) and x>> A <<M(FILL)>> for T8_drain_out:CHECK_DRAIN-[x]->FILL{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1194]: WLCS::Controller.impl
P [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1015]


[serial 1195]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]cc!(On)
Q [109] <<TURN_ON()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]


[serial 1196]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]cv := On
Q [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1194]: WLCS::Controller.impl
P [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: Q1 -> Q in sequential composition for [serial 1015]



[serial 1195]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]cc!(On)
Q [109] <<TURN_ON()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]



[serial 1196]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]cv := On
Q [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]


done reducing composite actions
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1194]: WLCS::Controller.impl
P [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91]->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Identity (id):  P->P is tautology
  What for: Q1 -> Q in sequential composition for [serial 1015]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [12.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1195]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]cc!(On)
Q [109] <<TURN_ON()>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]



[serial 1196]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]cv := On
Q [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]


Done trying to apply axioms
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=^(ASSERTION_FUNCTION[133] ^(LABEL COMMAND ) ^(CONDITIONAL_FUNCTION[72] ^(-> ^(( ^(or ^(INVOKE[72] STAY_SAME ) ^(INVOKE[72] TURN_ON ) ^(INVOKE[72] TURN_OFF ) ) ) ) nc ) ^(-> ^(( ^(INVOKE[73] TURN_OFF ) ) ) Off ) ^(-> ^(( ^(INVOKE[74] TURN_ON ) ) ) On ) ) )
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portAssertion=^(ASSERTION_FUNCTION[1] ^(INVOKE[1] COMMAND ) )
Making Proof Obligation for Conditional Expression for Port Output:  cc
referenced predicate=
  (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc, (TURN_OFF()) -> Off, (TURN_ON()) -> On
Thread "Controller.impl" has Dispatch_Protocol property Hybrid

This Proof Obligation:

[serial 1195]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]cc!(On)
Q [109] <<TURN_ON()>>
Reason:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]

Has applied <<pre and (cc=On)@now>> -> <<post>> for  <<pre>> cc!(On) <<post>> to get:

[serial 1197]: WLCS::Controller.impl
P [109] <<(cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30))
  and
  (cc = On)@now>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1195]

Has applied port output of conditional expression <<pre>> -> <<(TURN_ON())>>where (TURN_ON()) -> On for cc!(On) to get:

[serial 1198]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]->
Q [74] <<(TURN_ON())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1195]

solving assignment on line 109
Thread "Controller.impl" has Dispatch_Protocol property Hybrid
replacing "cv" with "On"
makes:  <<On = On and (TURN_ON() or STAY_SAME())>>

This Proof Obligation:

[serial 1196]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]cv := On
Q [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]

Has applied := to get:

[serial 1199]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (TURN_ON() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1196]

. . . done applying atomic actions [12.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1197]: WLCS::Controller.impl
P [109] <<(cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30))
  and
  (cc = On)@now>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1195]



[serial 1198]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]->
Q [74] <<(TURN_ON())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1195]



[serial 1199]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (TURN_ON() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1196]


Done reducing atomic actions
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 1197]: WLCS::Controller.impl
P [109] <<(cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30))
  and
  (cc = On)@now>>
S [109]->
Q [109] <<TURN_ON()>>
Reason:  Assume Present:  P = P@now = P^0 
  What for: applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1195]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 1200]: WLCS::Controller.impl
P [109] <<On = cc
  and
  (sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()))>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1197]

. . . done replacing P@now and P^0 with P  [12.5 seconds ]
After assuming present remaining 
Obligations:

[serial 1198]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]->
Q [74] <<(TURN_ON())>>
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1195]



[serial 1199]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (TURN_ON() or STAY_SAME())>>
  What for: applied wp for assignment [serial 1196]



[serial 1200]: WLCS::Controller.impl
P [109] <<On = cc
  and
  (sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()))>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1197]


Done assuming present.
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1198]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109]->
Q [74] <<(TURN_ON())>>
Reason:  Normalization
  What for: applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1195]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1202]: WLCS::Controller.impl
P [94] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF())>>
S [109]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1198]


This Proof Obligation:

[serial 1199]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (TURN_ON() or STAY_SAME())>>
Reason:  Normalization
  What for: applied wp for assignment [serial 1196]

  Normalization Axiom:

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1204]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (STAY_SAME() or TURN_ON())>>
  What for:   normalization of [serial 1199]

. . . done Normalizing Unsolved Proof Obligations [12.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1200]: WLCS::Controller.impl
P [109] <<On = cc
  and
  (sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()))>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: Assume Present:  P = P@now = P^0  [serial 1197]



[serial 1202]: WLCS::Controller.impl
P [94] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF())>>
S [109]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1198]



[serial 1204]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (STAY_SAME() or TURN_ON())>>
  What for:   normalization of [serial 1199]


Done Normalizing
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1200]: WLCS::Controller.impl
P [109] <<On = cc
  and
  (sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()))>>
S [109]->
Q [109] <<TURN_ON()>>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Assume Present:  P = P@now = P^0  [serial 1197]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1208]: WLCS::Controller.impl
P [109] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()) and On = cc>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1200]


This Proof Obligation:

[serial 1204]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<On = On and (STAY_SAME() or TURN_ON())>>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1199]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1209]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<true and (STAY_SAME() or TURN_ON())>>
  What for: Equality Law (idistr):  a=a <-> true [serial 1204]


This Proof Obligation:

[serial 1209]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<true and (STAY_SAME() or TURN_ON())>>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1204]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1210]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<((STAY_SAME() or TURN_ON()))>>
  What for: Law of And-Simplification:  P and true is P [serial 1209]

. . . done Applying Laws [12.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1202]: WLCS::Controller.impl
P [94] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF())>>
S [109]->
Q [74] <<TURN_ON()>>
  What for:   normalization of [serial 1198]



[serial 1208]: WLCS::Controller.impl
P [109] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()) and On = cc>>
S [109]->
Q [109] <<TURN_ON()>>
  What for: Associativity: (b.c).a = a.b.c [serial 1200]



[serial 1210]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<((STAY_SAME() or TURN_ON()))>>
  What for: Law of And-Simplification:  P and true is P [serial 1209]


Done applying laws
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1202]: WLCS::Controller.impl
P [94] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF())>>
S [109]->
Q [74] <<TURN_ON()>>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1198]

Has substituted Assertions' predicates for labels to get:

[serial 1211]: WLCS::Controller.impl
P [94] <<sw <= 30
  and
  Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
S [109]->
Q [74] <<(sw <= 30)>>
  What for: substituted Assertions' predicates for  labels  [serial 1202]


This Proof Obligation:

[serial 1208]: WLCS::Controller.impl
P [109] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()) and On = cc>>
S [109]->
Q [109] <<TURN_ON()>>
Reason:  Substitution of Assertion Labels
  What for: Associativity: (b.c).a = a.b.c [serial 1200]

Has substituted Assertions' predicates for labels to get:

[serial 1212]: WLCS::Controller.impl
P [109] <<sw <= 30
  and
  Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))
  and
  On = cc>>
S [109]->
Q [109] <<(sw <= 30)>>
  What for: substituted Assertions' predicates for  labels  [serial 1208]


This Proof Obligation:

[serial 1210]: WLCS::Controller.impl
P [109] <<TURN_ON()>>
S [109]->
Q [109] <<((STAY_SAME() or TURN_ON()))>>
Reason:  Substitution of Assertion Labels
  What for: Law of And-Simplification:  P and true is P [serial 1209]

Has substituted Assertions' predicates for labels to get:

[serial 1213]: WLCS::Controller.impl
P [109] <<(sw <= 30)>>
S [109]->
Q [109] <<((((sw > 30) and (sw < 60)) or (sw <= 30)))>>
  What for: substituted Assertions' predicates for  labels  [serial 1210]

. . . done Substituting Assertions for Labels [12.5 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1211]: WLCS::Controller.impl
P [94] <<sw <= 30
  and
  Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
S [109]->
Q [74] <<(sw <= 30)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1202]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1215]: WLCS::Controller.impl
P [94] <<sw <= 30
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109]->
Q [74] <<sw <= 30>>
  What for:   normalization of [serial 1211]


This Proof Obligation:

[serial 1212]: WLCS::Controller.impl
P [109] <<sw <= 30
  and
  Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))
  and
  On = cc>>
S [109]->
Q [109] <<(sw <= 30)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1208]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1217]: WLCS::Controller.impl
P [109] <<sw <= 30
  and
  Off = cv
  and
  On = cc
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109]->
Q [109] <<sw <= 30>>
  What for:   normalization of [serial 1212]


This Proof Obligation:

[serial 1213]: WLCS::Controller.impl
P [109] <<(sw <= 30)>>
S [109]->
Q [109] <<((((sw > 30) and (sw < 60)) or (sw <= 30)))>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1210]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Reflexivity of Disjunction: (m or k) = (k or m)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1219]: WLCS::Controller.impl
P [109] <<sw <= 30>>
S [109]->
Q [109] <<sw <= 30 or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1213]

. . . done Normalizing Unsolved Proof Obligations [12.5 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1215]: WLCS::Controller.impl
P [94] <<sw <= 30
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109]->
Q [74] <<sw <= 30>>
  What for:   normalization of [serial 1211]



[serial 1217]: WLCS::Controller.impl
P [109] <<sw <= 30
  and
  Off = cv
  and
  On = cc
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109]->
Q [109] <<sw <= 30>>
  What for:   normalization of [serial 1212]



[serial 1219]: WLCS::Controller.impl
P [109] <<sw <= 30>>
S [109]->
Q [109] <<sw <= 30 or (sw < 60 and 30 < sw)>>
  What for:   normalization of [serial 1213]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [12.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [12.6 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1215]: WLCS::Controller.impl
P [94] <<sw <= 30
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109]->
Q [74] <<sw <= 30>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1211]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1217]: WLCS::Controller.impl
P [109] <<sw <= 30
  and
  Off = cv
  and
  On = cc
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109]->
Q [109] <<sw <= 30>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1212]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1219]: WLCS::Controller.impl
P [109] <<sw <= 30>>
S [109]->
Q [109] <<sw <= 30 or (sw < 60 and 30 < sw)>>
Reason:  Or Introduction Schema (orcwl):  X->(X or Y)
  What for:   normalization of [serial 1213]

Has been solved by Or Introduction Schema (orcwl):  X->(X or Y)
. . . done Applying Axioms [12.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1016]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 61)>>
S [111]->
Q [95] <<OVERFLOW()>>
  What for:  <<M(CHECK_FILL) and x>> -> <<M(OVER_FLOW)>> for T9_overflow:CHECK_FILL-[x]->OVER_FLOW{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1016]  <<M(CHECK_FILL) and x>> -> <<M(OVER_FLOW)>> for T9_overflow:CHECK_FILL-[x]->OVER_FLOW{};
****axioms****
Applying Axioms . . .
. . . done Applying Axioms [12.6 seconds ]
After applying axioms, no change 
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1016]: WLCS::Controller.impl
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 61)>>
S [111]->
Q [95] <<OVERFLOW()>>
Reason:  Substitution of Assertion Labels
  What for:  <<M(CHECK_FILL) and x>> -> <<M(OVER_FLOW)>> for T9_overflow:CHECK_FILL-[x]->OVER_FLOW{};

Has substituted Assertions' predicates for labels to get:

[serial 1226]: WLCS::Controller.impl
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))
  and
  (sw >= 61)>>
S [111]->
Q [95] <<(sw >= 61)>>
  What for: substituted Assertions' predicates for  labels  [serial 1016]

. . . done Substituting Assertions for Labels [12.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1226]: WLCS::Controller.impl
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))
  and
  (sw >= 61)>>
S [111]->
Q [95] <<(sw >= 61)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1016]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1228]: WLCS::Controller.impl
P [93] <<61 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [111]->
Q [95] <<61 <= sw>>
  What for:   normalization of [serial 1226]

. . . done Normalizing Unsolved Proof Obligations [12.6 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1228]: WLCS::Controller.impl
P [93] <<61 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [111]->
Q [95] <<61 <= sw>>
  What for:   normalization of [serial 1226]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [12.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [12.6 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1228]: WLCS::Controller.impl
P [93] <<61 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [111]->
Q [95] <<61 <= sw>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1226]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1017]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 29)>>
S [112]->
Q [96] <<UNDERFLOW()>>
  What for:  <<M(CHECK_DRAIN) and x>> -> <<M(UNDER_FLOW)>> for T10_underflow:CHECK_DRAIN-[x]->UNDER_FLOW{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
#[serial 1017]  <<M(CHECK_DRAIN) and x>> -> <<M(UNDER_FLOW)>> for T10_underflow:CHECK_DRAIN-[x]->UNDER_FLOW{};
****completely substitute Assertions for labels****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1017]: WLCS::Controller.impl
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 29)>>
S [112]->
Q [96] <<UNDERFLOW()>>
Reason:  Substitution of Assertion Labels
  What for:  <<M(CHECK_DRAIN) and x>> -> <<M(UNDER_FLOW)>> for T10_underflow:CHECK_DRAIN-[x]->UNDER_FLOW{};

Has substituted Assertions' predicates for labels to get:

[serial 1231]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))
  and
  (sw <= 29)>>
S [112]->
Q [96] <<(sw <= 29)>>
  What for: substituted Assertions' predicates for  labels  [serial 1017]

. . . done Substituting Assertions for Labels [12.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1231]: WLCS::Controller.impl
P [94] <<cv = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))
  and
  (sw <= 29)>>
S [112]->
Q [96] <<(sw <= 29)>>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1017]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1233]: WLCS::Controller.impl
P [94] <<sw <= 29
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [112]->
Q [96] <<sw <= 29>>
  What for:   normalization of [serial 1231]

. . . done Normalizing Unsolved Proof Obligations [12.6 seconds ]
After "completely subsititute" round 0 remaining 
Obligations:

[serial 1233]: WLCS::Controller.impl
P [94] <<sw <= 29
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [112]->
Q [96] <<sw <= 29>>
  What for:   normalization of [serial 1231]


Done completely substituting, round 0.
Substituting Assertions for Labels . . .
. . . done Substituting Assertions for Labels [12.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [12.6 seconds ]
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1233]: WLCS::Controller.impl
P [94] <<sw <= 29
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [112]->
Q [96] <<sw <= 29>>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1231]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
Theorem (1)                               [serial 1003] 
P [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [78] ->
Q [78] <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (2)                               [serial 1004] 
P [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [78] ->
Q [78] <<TURN_ON() or TURN_OFF() or STAY_SAME()>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (3)                               [serial 1020] 
P [93] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
S [93] ->
Q [93] <<60 <= sw
or 61 <= sw
or (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))>>
by Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (4)                               [serial 1018] 
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))>>
S [93] ->
Q [93] <<((cv = On)
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30)))
or (sw >= 60)
or (sw >= 61)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 3:
Theorem (3) [serial 1020] used for:
    normalization of [serial 1018]
 


Theorem (5)                               [serial 1005] 
P [93] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [93] ->
Q [93] <<((cv = On)
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30)))
or (sw >= 60)
or (sw >= 61)>>
by Substitution of Assertion Labels
and theorem 4:
Theorem (4) [serial 1018] used for:
  substituted Assertions' predicates for  labels  [serial 1005]
 


Theorem (6)                               [serial 1025] 
P [94] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
S [94] ->
Q [94] <<sw <= 30
or sw <= 29
or (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))>>
by Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (7)                               [serial 1023] 
P [94] <<cv = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))>>
S [94] ->
Q [94] <<((cv = Off)
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60)))
or (sw <= 30)
or (sw <= 29)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 6:
Theorem (6) [serial 1025] used for:
    normalization of [serial 1023]
 


Theorem (8)                               [serial 1006] 
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [94] ->
Q [94] <<((cv = Off)
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60)))
or (sw <= 30)
or (sw <= 29)>>
by Substitution of Assertion Labels
and theorem 7:
Theorem (7) [serial 1023] used for:
  substituted Assertions' predicates for  labels  [serial 1006]
 


Theorem (9)                               [serial 1028] 
P [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92] ->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (10)                               [serial 1051] 
P [99] <<60 <= sw and Off = cv and Off = cc>>
S [99] ->
Q [99] <<60 <= sw>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (11)                               [serial 1043] 
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99] ->
Q [99] <<60 <= sw>>
by Associativity: (b.c).a = a.b.c
and theorem 10:
Theorem (10) [serial 1051] used for:
  Associativity: (b.c).a = a.b.c [serial 1043]
 


Theorem (12)                               [serial 1037] 
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99] ->
Q [99] <<(sw >= 60)>>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 11:
Theorem (11) [serial 1043] used for:
    normalization of [serial 1037]
 


Theorem (13)                               [serial 1034] 
P [99] <<Off = cc and (60 <= sw and Off = cv)>>
S [99] ->
Q [99] <<TURN_OFF()>>
by Substitution of Assertion Labels
and theorem 12:
Theorem (12) [serial 1037] used for:
  substituted Assertions' predicates for  labels  [serial 1034]
 


Theorem (14)                               [serial 1031] 
P [99] <<((cv = Off) and (sw >= 60))
  and
  (cc = Off)@now>>
S [99] ->
Q [99] <<TURN_OFF()>>
by Assume Present:  P = P@now = P^0 
and theorem 13:
Theorem (13) [serial 1034] used for:
  Assume Present:  P = P@now = P^0  [serial 1031]
 


Theorem (15)                               [serial 1039] 
P [90] <<60 <= sw and Off = cv>>
S [99] ->
Q [73] <<60 <= sw>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (16)                               [serial 1035] 
P [90] <<(cv = Off) and (sw >= 60)>>
S [99] ->
Q [73] <<((sw >= 60))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 15:
Theorem (15) [serial 1039] used for:
    normalization of [serial 1035]
 


Theorem (17)                               [serial 1032] 
P [90] <<(cv = Off) and (sw >= 60)>>
S [99] ->
Q [73] <<(TURN_OFF())>>
by Substitution of Assertion Labels
and theorem 16:
Theorem (16) [serial 1035] used for:
  substituted Assertions' predicates for  labels  [serial 1032]
 


Theorem (18)                               [serial 1029] 
P [90] <<(cv = Off) and (sw >= 60)>>
S [99] cc!(Off)
Q [99] <<TURN_OFF()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 14 17:
Theorem (14) [serial 1031] used for:
  applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1029]
 
Theorem (17) [serial 1032] used for:
  applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1029]
 


Theorem (19)                               [serial 1054] 
P [99] <<60 <= sw>>
S [99] ->
Q [99] <<60 <= sw or (sw < 60 and 30 < sw)>>
by Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (20)                               [serial 1052] 
P [99] <<60 <= sw>>
S [99] ->
Q [99] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 19:
Theorem (19) [serial 1054] used for:
    normalization of [serial 1052]
 


Theorem (21)                               [serial 1050] 
P [99] <<60 <= sw>>
S [99] ->
Q [99] <<true and (60 <= sw or (sw < 60 and 30 < sw))>>
by Law of And-Simplification:  P and true is P
and theorem 20:
Theorem (20) [serial 1052] used for:
  Law of And-Simplification:  P and true is P [serial 1050]
 


Theorem (22)                               [serial 1041] 
P [99] <<60 <= sw>>
S [99] ->
Q [99] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
by Equality Law (idistr):  a=a <-> true
and theorem 21:
Theorem (21) [serial 1050] used for:
  Equality Law (idistr):  a=a <-> true [serial 1041]
 


Theorem (23)                               [serial 1036] 
P [99] <<(sw >= 60)>>
S [99] ->
Q [99] <<Off = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 22:
Theorem (22) [serial 1041] used for:
    normalization of [serial 1036]
 


Theorem (24)                               [serial 1033] 
P [99] <<TURN_OFF()>>
S [99] ->
Q [99] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
by Substitution of Assertion Labels
and theorem 23:
Theorem (23) [serial 1036] used for:
  substituted Assertions' predicates for  labels  [serial 1033]
 


Theorem (25)                               [serial 1030] 
P [99] <<TURN_OFF()>>
S [99] cv := Off
Q [99] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 24:
Theorem (24) [serial 1033] used for:
  applied wp for assignment [serial 1030]
 


Theorem (26)                               [serial 1007] 
P [90] <<(cv = Off) and (sw >= 60)>>
S [99] cc!(Off)
;
<<TURN_OFF()>>
cv := Off
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 9 18 25:
Theorem (9) [serial 1028] used for:
  Q1 -> Q in sequential composition for [serial 1007]
 
Theorem (18) [serial 1029] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1007]
 
Theorem (25) [serial 1030] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1007]
 


Theorem (27)                               [serial 1056] 
P [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91] ->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (28)                               [serial 1087] 
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100] ->
Q [100] <<sw <= 30>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (29)                               [serial 1083] 
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100] ->
Q [100] <<(sw <= 30)>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 28:
Theorem (28) [serial 1087] used for:
    normalization of [serial 1083]
 


Theorem (30)                               [serial 1081] 
P [100] <<sw <= 30 and Off = cv and On = cc>>
S [100] ->
Q [100] <<TURN_ON()>>
by Substitution of Assertion Labels
and theorem 29:
Theorem (29) [serial 1083] used for:
  substituted Assertions' predicates for  labels  [serial 1081]
 


Theorem (31)                               [serial 1076] 
P [100] <<sw <= 30 and (On = cc)@now and Off = cv>>
S [100] ->
Q [100] <<TURN_ON()>>
by Assume Present:  P = P@now = P^0 
and theorem 30:
Theorem (30) [serial 1081] used for:
  Assume Present:  P = P@now = P^0  [serial 1076]
 


Theorem (32)                               [serial 1071] 
P [100] <<sw <= 30 and Off = cv and (On = cc)@now>>
S [100] ->
Q [100] <<TURN_ON()>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 31:
Theorem (31) [serial 1076] used for:
    normalization of [serial 1071]
 


Theorem (33)                               [serial 1063] 
P [100] <<(On = cc)@now and (sw <= 30 and Off = cv)>>
S [100] ->
Q [100] <<TURN_ON()>>
by Associativity: (b.c).a = a.b.c
and theorem 32:
Theorem (32) [serial 1071] used for:
  Associativity: (b.c).a = a.b.c [serial 1063]
 


Theorem (34)                               [serial 1059] 
P [100] <<((cv = Off) and (sw <= 30))
  and
  (cc = On)@now>>
S [100] ->
Q [100] <<TURN_ON()>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 33:
Theorem (33) [serial 1063] used for:
    normalization of [serial 1059]
 


Theorem (35)                               [serial 1085] 
P [90] <<sw <= 30 and Off = cv>>
S [100] ->
Q [74] <<sw <= 30>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (36)                               [serial 1082] 
P [90] <<sw <= 30 and Off = cv>>
S [100] ->
Q [74] <<(sw <= 30)>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 35:
Theorem (35) [serial 1085] used for:
    normalization of [serial 1082]
 


Theorem (37)                               [serial 1065] 
P [90] <<sw <= 30 and Off = cv>>
S [100] ->
Q [74] <<TURN_ON()>>
by Substitution of Assertion Labels
and theorem 36:
Theorem (36) [serial 1082] used for:
  substituted Assertions' predicates for  labels  [serial 1065]
 


Theorem (38)                               [serial 1060] 
P [90] <<(cv = Off) and (sw <= 30)>>
S [100] ->
Q [74] <<(TURN_ON())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 37:
Theorem (37) [serial 1065] used for:
    normalization of [serial 1060]
 


Theorem (39)                               [serial 1057] 
P [90] <<(cv = Off) and (sw <= 30)>>
S [100] cc!(On)
Q [100] <<TURN_ON()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 34 38:
Theorem (34) [serial 1059] used for:
  applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1057]
 
Theorem (38) [serial 1060] used for:
  applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1057]
 


Theorem (40)                               [serial 1078] 
P [100] <<TURN_ON()>>
S [100] ->
Q [100] <<STAY_SAME() or TURN_ON()>>
by Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (41)                               [serial 1073] 
P [100] <<TURN_ON()>>
S [100] ->
Q [100] <<((STAY_SAME() or TURN_ON()))>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 40:
Theorem (40) [serial 1078] used for:
    normalization of [serial 1073]
 


Theorem (42)                               [serial 1072] 
P [100] <<TURN_ON()>>
S [100] ->
Q [100] <<true and (STAY_SAME() or TURN_ON())>>
by Law of And-Simplification:  P and true is P
and theorem 41:
Theorem (41) [serial 1073] used for:
  Law of And-Simplification:  P and true is P [serial 1072]
 


Theorem (43)                               [serial 1067] 
P [100] <<TURN_ON()>>
S [100] ->
Q [100] <<On = On and (STAY_SAME() or TURN_ON())>>
by Equality Law (idistr):  a=a <-> true
and theorem 42:
Theorem (42) [serial 1072] used for:
  Equality Law (idistr):  a=a <-> true [serial 1067]
 


Theorem (44)                               [serial 1061] 
P [100] <<TURN_ON()>>
S [100] ->
Q [100] <<On = On and (TURN_ON() or STAY_SAME())>>
by Normalization
  Normalization Axiom:
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 43:
Theorem (43) [serial 1067] used for:
    normalization of [serial 1061]
 


Theorem (45)                               [serial 1058] 
P [100] <<TURN_ON()>>
S [100] cv := On
Q [100] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 44:
Theorem (44) [serial 1061] used for:
  applied wp for assignment [serial 1058]
 


Theorem (46)                               [serial 1008] 
P [90] <<(cv = Off) and (sw <= 30)>>
S [100] cc!(On)
;
<<TURN_ON()>>
cv := On
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 27 39 45:
Theorem (27) [serial 1056] used for:
  Q1 -> Q in sequential composition for [serial 1008]
 
Theorem (39) [serial 1057] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1008]
 
Theorem (45) [serial 1058] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1008]
 


Theorem (47)                               [serial 1092] 
P [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92] ->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (48)                               [serial 1113] 
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101] ->
Q [101] <<Off = cv>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (49)                               [serial 1116] 
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101] ->
Q [101] <<60 <= sw or (sw < 60 and 30 < sw)>>
by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (50)                               [serial 1114] 
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101] ->
Q [101] <<(60 <= sw or (sw < 60 and 30 < sw))>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 49:
Theorem (49) [serial 1116] used for:
    normalization of [serial 1114]
 


Theorem (51)                               [serial 1111] 
P [101] <<Off = cv and cc = nc and sw < 60 and 30 < sw>>
S [101] ->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 48 50:
Theorem (48) [serial 1113] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]
 
Theorem (50) [serial 1114] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1111]
 


Theorem (52)                               [serial 1109] 
P [101] <<sw < 60 and 30 < sw and Off = cv and cc = nc>>
S [101] ->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 51:
Theorem (51) [serial 1111] used for:
    normalization of [serial 1109]
 


Theorem (53)                               [serial 1108] 
P [101] <<Off = cv and (sw < 60 and 30 < sw) and cc = nc>>
S [101] ->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Associativity: (b.c).a = a.b.c
and theorem 52:
Theorem (52) [serial 1109] used for:
  Associativity: (b.c).a = a.b.c [serial 1108]
 


Theorem (54)                               [serial 1102] 
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101] ->
Q [101] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Associativity: (b.c).a = a.b.c
and theorem 53:
Theorem (53) [serial 1108] used for:
  Associativity: (b.c).a = a.b.c [serial 1102]
 


Theorem (55)                               [serial 1098] 
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101] ->
Q [101] <<Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 54:
Theorem (54) [serial 1102] used for:
    normalization of [serial 1098]
 


Theorem (56)                               [serial 1096] 
P [101] <<cc = nc and (Off = cv and (sw < 60 and 30 < sw))>>
S [101] ->
Q [101] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
by Substitution of Assertion Labels
and theorem 55:
Theorem (55) [serial 1098] used for:
  substituted Assertions' predicates for  labels  [serial 1096]
 


Theorem (57)                               [serial 1094] 
P [101] <<((cv = Off) and ((sw > 30) and (sw < 60)))
  and
  (cc = nc)@now>>
S [101] ->
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Assume Present:  P = P@now = P^0 
and theorem 56:
Theorem (56) [serial 1096] used for:
  Assume Present:  P = P@now = P^0  [serial 1094]
 


Theorem (58)                               [serial 1107] 
P [90] <<sw < 60 and 30 < sw and Off = cv>>
S [101] ->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (59)                               [serial 1100] 
P [90] <<Off = cv and (sw < 60 and 30 < sw)>>
S [101] ->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
by Associativity: (b.c).a = a.b.c
and theorem 58:
Theorem (58) [serial 1107] used for:
  Associativity: (b.c).a = a.b.c [serial 1100]
 


Theorem (60)                               [serial 1097] 
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101] ->
Q [72] <<(((sw > 30) and (sw < 60))
or (sw <= 30)
or (sw >= 60))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 59:
Theorem (59) [serial 1100] used for:
    normalization of [serial 1097]
 


Theorem (61)                               [serial 1095] 
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101] ->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
by Substitution of Assertion Labels
and theorem 60:
Theorem (60) [serial 1097] used for:
  substituted Assertions' predicates for  labels  [serial 1095]
 


Theorem (62)                               [serial 1093] 
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101] cc!(nc)
Q [101] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 57 61:
Theorem (57) [serial 1094] used for:
  applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1093]
 
Theorem (61) [serial 1095] used for:
  applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1093]
 


Theorem (63)                               [serial 1009] 
P [90] <<(cv = Off) and ((sw > 30) and (sw < 60))>>
S [101] cc!(nc)
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Introduction of Existential Quantification (bl.aapost)
and theorems 47 62:
Theorem (47) [serial 1092] used for:
  as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]
 
Theorem (62) [serial 1093] used for:
  as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1009]
 


Theorem (64)                               [serial 1010] 
P [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [103] ->
Q [93] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (65)                               [serial 1118] 
P [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91] ->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (66)                               [serial 1135] 
P [104] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104] ->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (67)                               [serial 1134] 
P [104] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [104] ->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
by Associativity: (b.c).a = a.b.c
and theorem 66:
Theorem (66) [serial 1135] used for:
  Associativity: (b.c).a = a.b.c [serial 1134]
 


Theorem (68)                               [serial 1128] 
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [104] ->
Q [104] <<On = cv and (sw <= 30 or (sw < 60 and 30 < sw))>>
by Associativity: (b.c).a = a.b.c
and theorem 67:
Theorem (67) [serial 1134] used for:
  Associativity: (b.c).a = a.b.c [serial 1128]
 


Theorem (69)                               [serial 1124] 
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104] ->
Q [104] <<On = cv
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30))>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 68:
Theorem (68) [serial 1128] used for:
    normalization of [serial 1124]
 


Theorem (70)                               [serial 1122] 
P [104] <<cc = nc
  and
  (On = cv
    and
    (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_ON()))>>
S [104] ->
Q [104] <<On = cv and (STAY_SAME() or TURN_ON())>>
by Substitution of Assertion Labels
and theorem 69:
Theorem (69) [serial 1124] used for:
  substituted Assertions' predicates for  labels  [serial 1122]
 


Theorem (71)                               [serial 1120] 
P [104] <<(cv = On
    and
    (TURN_ON() or STAY_SAME())
    and
    ((cv = On)
      and
      (((sw > 30) and (sw < 60)) or (sw <= 30))))
  and
  (cc = nc)@now>>
S [104] ->
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Assume Present:  P = P@now = P^0 
and theorem 70:
Theorem (70) [serial 1122] used for:
  Assume Present:  P = P@now = P^0  [serial 1120]
 


Theorem (72)                               [serial 1133] 
P [93] <<On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104] ->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (73)                               [serial 1126] 
P [93] <<On = cv
  and
  (On = cv and (sw <= 30 or (sw < 60 and 30 < sw)))
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [104] ->
Q [72] <<sw <= 30 or 60 <= sw or (sw < 60 and 30 < sw)>>
by Associativity: (b.c).a = a.b.c
and theorem 72:
Theorem (72) [serial 1133] used for:
  Associativity: (b.c).a = a.b.c [serial 1126]
 


Theorem (74)                               [serial 1123] 
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104] ->
Q [72] <<(((sw > 30) and (sw < 60))
or (sw <= 30)
or (sw >= 60))>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 73:
Theorem (73) [serial 1126] used for:
    normalization of [serial 1123]
 


Theorem (75)                               [serial 1121] 
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104] ->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
by Substitution of Assertion Labels
and theorem 74:
Theorem (74) [serial 1123] used for:
  substituted Assertions' predicates for  labels  [serial 1121]
 


Theorem (76)                               [serial 1119] 
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104] cc!(nc)
Q [104] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 71 75:
Theorem (71) [serial 1120] used for:
  applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1119]
 
Theorem (75) [serial 1121] used for:
  applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1119]
 


Theorem (77)                               [serial 1011] 
P [93] <<cv = On
  and
  (TURN_ON() or STAY_SAME())
  and
  ((cv = On)
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [104] cc!(nc)
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Introduction of Existential Quantification (bl.aapost)
and theorems 65 76:
Theorem (65) [serial 1118] used for:
  as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]
 
Theorem (76) [serial 1119] used for:
  as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1011]
 


Theorem (78)                               [serial 1136] 
P [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92] ->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (79)                               [serial 1171] 
P [105] <<60 <= sw
  and
  Off = cc
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105] ->
Q [105] <<60 <= sw>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (80)                               [serial 1168] 
P [105] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))
  and
  Off = cc>>
S [105] ->
Q [105] <<60 <= sw>>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 79:
Theorem (79) [serial 1171] used for:
    normalization of [serial 1168]
 


Theorem (81)                               [serial 1160] 
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (sw <= 30 or (sw < 60 and 30 < sw)))>>
S [105] ->
Q [105] <<60 <= sw>>
by Associativity: (b.c).a = a.b.c
and theorem 80:
Theorem (80) [serial 1168] used for:
  Associativity: (b.c).a = a.b.c [serial 1160]
 


Theorem (82)                               [serial 1154] 
P [105] <<Off = cc
  and
  (60 <= sw
    and
    On = cv
    and
    (((sw > 30) and (sw < 60)) or (sw <= 30)))>>
S [105] ->
Q [105] <<(sw >= 60)>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 81:
Theorem (81) [serial 1160] used for:
    normalization of [serial 1154]
 


Theorem (83)                               [serial 1151] 
P [105] <<Off = cc
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105] ->
Q [105] <<TURN_OFF()>>
by Substitution of Assertion Labels
and theorem 82:
Theorem (82) [serial 1154] used for:
  substituted Assertions' predicates for  labels  [serial 1151]
 


Theorem (84)                               [serial 1143] 
P [105] <<(Off = cc)@now
  and
  (60 <= sw and On = cv and (STAY_SAME() or TURN_ON()))>>
S [105] ->
Q [105] <<TURN_OFF()>>
by Assume Present:  P = P@now = P^0 
and theorem 83:
Theorem (83) [serial 1151] used for:
  Assume Present:  P = P@now = P^0  [serial 1143]
 


Theorem (85)                               [serial 1139] 
P [105] <<(cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60))
  and
  (cc = Off)@now>>
S [105] ->
Q [105] <<TURN_OFF()>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 84:
Theorem (84) [serial 1143] used for:
    normalization of [serial 1139]
 


Theorem (86)                               [serial 1156] 
P [93] <<60 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [105] ->
Q [73] <<60 <= sw>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (87)                               [serial 1152] 
P [93] <<60 <= sw
  and
  On = cv
  and
  (((sw > 30) and (sw < 60)) or (sw <= 30))>>
S [105] ->
Q [73] <<(sw >= 60)>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 86:
Theorem (86) [serial 1156] used for:
    normalization of [serial 1152]
 


Theorem (88)                               [serial 1145] 
P [93] <<60 <= sw and On = cv and (STAY_SAME() or TURN_ON())>>
S [105] ->
Q [73] <<TURN_OFF()>>
by Substitution of Assertion Labels
and theorem 87:
Theorem (87) [serial 1152] used for:
  substituted Assertions' predicates for  labels  [serial 1145]
 


Theorem (89)                               [serial 1140] 
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105] ->
Q [73] <<(TURN_OFF())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 88:
Theorem (88) [serial 1145] used for:
    normalization of [serial 1140]
 


Theorem (90)                               [serial 1137] 
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105] cc!(Off)
Q [105] <<TURN_OFF()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 85 89:
Theorem (85) [serial 1139] used for:
  applied port output <<pre and (cc=Off)@now>> -> <<post>> [serial 1137]
 
Theorem (89) [serial 1140] used for:
  applied port output of conditional expression <<pre>> -> <<(TURN_OFF())>> where (TURN_OFF()) -> Off for cc!(Off) 
[serial 1137]
 


Theorem (91)                               [serial 1173] 
P [105] <<60 <= sw>>
S [105] ->
Q [105] <<60 <= sw or (sw < 60 and 30 < sw)>>
by Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (92)                               [serial 1169] 
P [105] <<60 <= sw>>
S [105] ->
Q [105] <<((60 <= sw or (sw < 60 and 30 < sw)))>>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 91:
Theorem (91) [serial 1173] used for:
    normalization of [serial 1169]
 


Theorem (93)                               [serial 1167] 
P [105] <<60 <= sw>>
S [105] ->
Q [105] <<true and (60 <= sw or (sw < 60 and 30 < sw))>>
by Law of And-Simplification:  P and true is P
and theorem 92:
Theorem (92) [serial 1169] used for:
  Law of And-Simplification:  P and true is P [serial 1167]
 


Theorem (94)                               [serial 1158] 
P [105] <<60 <= sw>>
S [105] ->
Q [105] <<Off = Off and (60 <= sw or (sw < 60 and 30 < sw))>>
by Equality Law (idistr):  a=a <-> true
and theorem 93:
Theorem (93) [serial 1167] used for:
  Equality Law (idistr):  a=a <-> true [serial 1158]
 


Theorem (95)                               [serial 1153] 
P [105] <<(sw >= 60)>>
S [105] ->
Q [105] <<Off = Off
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 94:
Theorem (94) [serial 1158] used for:
    normalization of [serial 1153]
 


Theorem (96)                               [serial 1147] 
P [105] <<TURN_OFF()>>
S [105] ->
Q [105] <<Off = Off and (STAY_SAME() or TURN_OFF())>>
by Substitution of Assertion Labels
and theorem 95:
Theorem (95) [serial 1153] used for:
  substituted Assertions' predicates for  labels  [serial 1147]
 


Theorem (97)                               [serial 1141] 
P [105] <<TURN_OFF()>>
S [105] ->
Q [105] <<Off = Off and (TURN_OFF() or STAY_SAME())>>
by Normalization
  Normalization Axiom:
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 96:
Theorem (96) [serial 1147] used for:
    normalization of [serial 1141]
 


Theorem (98)                               [serial 1138] 
P [105] <<TURN_OFF()>>
S [105] cv := Off
Q [105] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 97:
Theorem (97) [serial 1141] used for:
  applied wp for assignment [serial 1138]
 


Theorem (99)                               [serial 1012] 
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 60)>>
S [105] cc!(Off)
;
<<TURN_OFF()>>
cv := Off
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 78 90 98:
Theorem (78) [serial 1136] used for:
  Q1 -> Q in sequential composition for [serial 1012]
 
Theorem (90) [serial 1137] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1012]
 
Theorem (98) [serial 1138] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1012]
 


Theorem (100)                               [serial 1013] 
P [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [107] ->
Q [94] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (101)                               [serial 1176] 
P [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
S [92] ->
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (102)                               [serial 1192] 
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108] ->
Q [108] <<Off = cv>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (103)                               [serial 1193] 
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108] ->
Q [108] <<(60 <= sw or (sw < 60 and 30 < sw))>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (104)                               [serial 1191] 
P [108] <<Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108] ->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 102 103:
Theorem (102) [serial 1192] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]
 
Theorem (103) [serial 1193] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1191]
 


Theorem (105)                               [serial 1190] 
P [108] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (60 <= sw or (sw < 60 and 30 < sw))
  and
  cc = nc>>
S [108] ->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Associativity: (b.c).a = a.b.c
and theorem 104:
Theorem (104) [serial 1191] used for:
  Associativity: (b.c).a = a.b.c [serial 1190]
 


Theorem (106)                               [serial 1187] 
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (60 <= sw or (sw < 60 and 30 < sw)))>>
S [108] ->
Q [108] <<Off = cv and (60 <= sw or (sw < 60 and 30 < sw))>>
by Associativity: (b.c).a = a.b.c
and theorem 105:
Theorem (105) [serial 1190] used for:
  Associativity: (b.c).a = a.b.c [serial 1187]
 


Theorem (107)                               [serial 1185] 
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108] ->
Q [108] <<Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 106:
Theorem (106) [serial 1187] used for:
    normalization of [serial 1185]
 


Theorem (108)                               [serial 1180] 
P [108] <<cc = nc
  and
  (Off = cv
    and
    (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
    and
    (STAY_SAME() or TURN_OFF()))>>
S [108] ->
Q [108] <<Off = cv and (STAY_SAME() or TURN_OFF())>>
by Substitution of Assertion Labels
and theorem 107:
Theorem (107) [serial 1185] used for:
  substituted Assertions' predicates for  labels  [serial 1180]
 


Theorem (109)                               [serial 1178] 
P [108] <<(cv = Off
    and
    (TURN_OFF() or STAY_SAME())
    and
    ((cv = Off)
      and
      (((sw > 30) and (sw < 60)) or (sw >= 60))))
  and
  (cc = nc)@now>>
S [108] ->
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Assume Present:  P = P@now = P^0 
and theorem 108:
Theorem (108) [serial 1180] used for:
  Assume Present:  P = P@now = P^0  [serial 1178]
 


Theorem (110)                               [serial 1182] 
P [94] <<Off = cv
  and
  (Off = cv and (60 <= sw or (sw < 60 and 30 < sw)))
  and
  (STAY_SAME() or TURN_OFF())>>
S [108] ->
Q [72] <<STAY_SAME() or TURN_OFF() or TURN_ON()>>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (111)                               [serial 1179] 
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108] ->
Q [72] <<(STAY_SAME() or TURN_ON() or TURN_OFF())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 110:
Theorem (110) [serial 1182] used for:
    normalization of [serial 1179]
 


Theorem (112)                               [serial 1177] 
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108] cc!(nc)
Q [108] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 109 111:
Theorem (109) [serial 1178] used for:
  applied port output <<pre and (cc=nc)@now>> -> <<post>> [serial 1177]
 
Theorem (111) [serial 1179] used for:
  applied port output of conditional expression <<pre>> -> <<(STAY_SAME() or TURN_ON() or TURN_OFF())>> where (STAY_SAME() or TURN_ON() or TURN_OFF()) -> nc for cc!(nc) 
[serial 1177]
 


Theorem (113)                               [serial 1014] 
P [94] <<cv = Off
  and
  (TURN_OFF() or STAY_SAME())
  and
  ((cv = Off)
    and
    (((sw > 30) and (sw < 60)) or (sw >= 60)))>>
S [108] cc!(nc)
<<cv = Off and (TURN_OFF() or STAY_SAME())>>
Q [92] <<cv = Off and (TURN_OFF() or STAY_SAME())>>
by Introduction of Existential Quantification (bl.aapost)
and theorems 101 112:
Theorem (101) [serial 1176] used for:
  as <<post>> -> <<Q>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]
 
Theorem (112) [serial 1177] used for:
  as <<P>> S <<post>> in <<P>> {  S <<post>> } <<Q>> [serial 1014]
 


Theorem (114)                               [serial 1194] 
P [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
S [91] ->
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Identity (id):  P->P is tautology


Theorem (115)                               [serial 1217] 
P [109] <<sw <= 30
  and
  Off = cv
  and
  On = cc
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109] ->
Q [109] <<sw <= 30>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (116)                               [serial 1212] 
P [109] <<sw <= 30
  and
  Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))
  and
  On = cc>>
S [109] ->
Q [109] <<(sw <= 30)>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 115:
Theorem (115) [serial 1217] used for:
    normalization of [serial 1212]
 


Theorem (117)                               [serial 1208] 
P [109] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()) and On = cc>>
S [109] ->
Q [109] <<TURN_ON()>>
by Substitution of Assertion Labels
and theorem 116:
Theorem (116) [serial 1212] used for:
  substituted Assertions' predicates for  labels  [serial 1208]
 


Theorem (118)                               [serial 1200] 
P [109] <<On = cc
  and
  (sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF()))>>
S [109] ->
Q [109] <<TURN_ON()>>
by Associativity: (b.c).a = a.b.c
and theorem 117:
Theorem (117) [serial 1208] used for:
  Associativity: (b.c).a = a.b.c [serial 1200]
 


Theorem (119)                               [serial 1197] 
P [109] <<(cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30))
  and
  (cc = On)@now>>
S [109] ->
Q [109] <<TURN_ON()>>
by Assume Present:  P = P@now = P^0 
and theorem 118:
Theorem (118) [serial 1200] used for:
  Assume Present:  P = P@now = P^0  [serial 1197]
 


Theorem (120)                               [serial 1215] 
P [94] <<sw <= 30
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [109] ->
Q [74] <<sw <= 30>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (121)                               [serial 1211] 
P [94] <<sw <= 30
  and
  Off = cv
  and
  (((sw > 30) and (sw < 60)) or (sw >= 60))>>
S [109] ->
Q [74] <<(sw <= 30)>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 120:
Theorem (120) [serial 1215] used for:
    normalization of [serial 1211]
 


Theorem (122)                               [serial 1202] 
P [94] <<sw <= 30 and Off = cv and (STAY_SAME() or TURN_OFF())>>
S [109] ->
Q [74] <<TURN_ON()>>
by Substitution of Assertion Labels
and theorem 121:
Theorem (121) [serial 1211] used for:
  substituted Assertions' predicates for  labels  [serial 1202]
 


Theorem (123)                               [serial 1198] 
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109] ->
Q [74] <<(TURN_ON())>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 122:
Theorem (122) [serial 1202] used for:
    normalization of [serial 1198]
 


Theorem (124)                               [serial 1195] 
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109] cc!(On)
Q [109] <<TURN_ON()>>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 119 123:
Theorem (119) [serial 1197] used for:
  applied port output <<pre and (cc=On)@now>> -> <<post>> [serial 1195]
 
Theorem (123) [serial 1198] used for:
  applied port output of conditional expression <<pre>> -> <<(TURN_ON())>> where (TURN_ON()) -> On for cc!(On) 
[serial 1195]
 


Theorem (125)                               [serial 1219] 
P [109] <<sw <= 30>>
S [109] ->
Q [109] <<sw <= 30 or (sw < 60 and 30 < sw)>>
by Or Introduction Schema (orcwl):  X->(X or Y)


Theorem (126)                               [serial 1213] 
P [109] <<(sw <= 30)>>
S [109] ->
Q [109] <<((((sw > 30) and (sw < 60)) or (sw <= 30)))>>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 125:
Theorem (125) [serial 1219] used for:
    normalization of [serial 1213]
 


Theorem (127)                               [serial 1210] 
P [109] <<TURN_ON()>>
S [109] ->
Q [109] <<((STAY_SAME() or TURN_ON()))>>
by Substitution of Assertion Labels
and theorem 126:
Theorem (126) [serial 1213] used for:
  substituted Assertions' predicates for  labels  [serial 1210]
 


Theorem (128)                               [serial 1209] 
P [109] <<TURN_ON()>>
S [109] ->
Q [109] <<true and (STAY_SAME() or TURN_ON())>>
by Law of And-Simplification:  P and true is P
and theorem 127:
Theorem (127) [serial 1210] used for:
  Law of And-Simplification:  P and true is P [serial 1209]
 


Theorem (129)                               [serial 1204] 
P [109] <<TURN_ON()>>
S [109] ->
Q [109] <<On = On and (STAY_SAME() or TURN_ON())>>
by Equality Law (idistr):  a=a <-> true
and theorem 128:
Theorem (128) [serial 1209] used for:
  Equality Law (idistr):  a=a <-> true [serial 1204]
 


Theorem (130)                               [serial 1199] 
P [109] <<TURN_ON()>>
S [109] ->
Q [109] <<On = On and (TURN_ON() or STAY_SAME())>>
by Normalization
  Normalization Axiom:
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 129:
Theorem (129) [serial 1204] used for:
    normalization of [serial 1199]
 


Theorem (131)                               [serial 1196] 
P [109] <<TURN_ON()>>
S [109] cv := On
Q [109] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 130:
Theorem (130) [serial 1199] used for:
  applied wp for assignment [serial 1196]
 


Theorem (132)                               [serial 1015] 
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 30)>>
S [109] cc!(On)
;
<<TURN_ON()>>
cv := On
<<cv = On and (TURN_ON() or STAY_SAME())>>
Q [91] <<cv = On and (TURN_ON() or STAY_SAME())>>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 114 124 131:
Theorem (114) [serial 1194] used for:
  Q1 -> Q in sequential composition for [serial 1015]
 
Theorem (124) [serial 1195] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]
 
Theorem (131) [serial 1196] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]
 


Theorem (133)                               [serial 1228] 
P [93] <<61 <= sw
  and
  On = cv
  and
  (sw <= 30 or (sw < 60 and 30 < sw))>>
S [111] ->
Q [95] <<61 <= sw>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (134)                               [serial 1226] 
P [93] <<cv = On
  and
  ((sw <= 30) or ((sw > 30) and (sw < 60)))
  and
  (sw >= 61)>>
S [111] ->
Q [95] <<(sw >= 61)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 133:
Theorem (133) [serial 1228] used for:
    normalization of [serial 1226]
 


Theorem (135)                               [serial 1016] 
P [93] <<cv = On and (TURN_ON() or STAY_SAME()) and (sw >= 61)>>
S [111] ->
Q [95] <<OVERFLOW()>>
by Substitution of Assertion Labels
and theorem 134:
Theorem (134) [serial 1226] used for:
  substituted Assertions' predicates for  labels  [serial 1016]
 


Theorem (136)                               [serial 1233] 
P [94] <<sw <= 29
  and
  Off = cv
  and
  (60 <= sw or (sw < 60 and 30 < sw))>>
S [112] ->
Q [96] <<sw <= 29>>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (137)                               [serial 1231] 
P [94] <<cv = Off
  and
  ((sw >= 60) or ((sw > 30) and (sw < 60)))
  and
  (sw <= 29)>>
S [112] ->
Q [96] <<(sw <= 29)>>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 136:
Theorem (136) [serial 1233] used for:
    normalization of [serial 1231]
 


Theorem (138)                               [serial 1017] 
P [94] <<cv = Off and (TURN_OFF() or STAY_SAME()) and (sw <= 29)>>
S [112] ->
Q [96] <<UNDERFLOW()>>
by Substitution of Assertion Labels
and theorem 137:
Theorem (137) [serial 1231] used for:
  substituted Assertions' predicates for  labels  [serial 1017]
 


Theorem (139)                               [serial 1002] 
P [89] << >>
S [78] ->
Q [89] <<Controller.impl proof obligations>>
by Initial Thread Obligations
and theorems 1 2 5 8 26 46 63 64 77 99 100 113 132 135 138:
Theorem (1) [serial 1003] used for:
  <<M(FILL)>> -> <<I>> from invariant I when complete state FILL has Assertion <<M(FILL)>> in its definition.
 
Theorem (2) [serial 1004] used for:
  <<M(DRAIN)>> -> <<I>> from invariant I when complete state DRAIN has Assertion <<M(DRAIN)>> in its definition.
 
Theorem (5) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_FILL, <<M(CHECK_FILL)>> -> <<e1 or e2 or . . . en>>
 
Theorem (8) [serial 1006] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CHECK_DRAIN, <<M(CHECK_DRAIN)>> -> <<e1 or e2 or . . . en>>
 
Theorem (26) [serial 1007] used for:
   <<M(START) and x>> A <<M(DRAIN)>> for T0_start:START-[x]->DRAIN{A};
 
Theorem (46) [serial 1008] used for:
   <<M(START) and x>> A <<M(FILL)>> for T1_start:START-[x]->FILL{A};
 
Theorem (63) [serial 1009] used for:
   <<M(START) and x>> A <<M(DRAIN)>> for T2_start:START-[x]->DRAIN{A};
 
Theorem (64) [serial 1010] used for:
   <<M(FILL) and x>> -> <<M(CHECK_FILL)>> for T3_check_fill:FILL-[x]->CHECK_FILL{};
 
Theorem (77) [serial 1011] used for:
   <<M(CHECK_FILL) and x>> A <<M(FILL)>> for T4_fill_ok:CHECK_FILL-[x]->FILL{A};
 
Theorem (99) [serial 1012] used for:
   <<M(CHECK_FILL) and x>> A <<M(DRAIN)>> for T5_fill_out:CHECK_FILL-[x]->DRAIN{A};
 
Theorem (100) [serial 1013] used for:
   <<M(DRAIN) and x>> -> <<M(CHECK_DRAIN)>> for T6_check_drain:DRAIN-[x]->CHECK_DRAIN{};
 
Theorem (113) [serial 1014] used for:
   <<M(CHECK_DRAIN) and x>> A <<M(DRAIN)>> for T7_drain_ok:CHECK_DRAIN-[x]->DRAIN{A};
 
Theorem (132) [serial 1015] used for:
   <<M(CHECK_DRAIN) and x>> A <<M(FILL)>> for T8_drain_out:CHECK_DRAIN-[x]->FILL{A};
 
Theorem (135) [serial 1016] used for:
   <<M(CHECK_FILL) and x>> -> <<M(OVER_FLOW)>> for T9_overflow:CHECK_FILL-[x]->OVER_FLOW{};
 
Theorem (138) [serial 1017] used for:
   <<M(CHECK_DRAIN) and x>> -> <<M(UNDER_FLOW)>> for T10_underflow:CHECK_DRAIN-[x]->UNDER_FLOW{};
 


Theorem (140)                               [serial 1001] 
P     
S     
Q     
by Initial Thread Obligations
and theorem 139:
Theorem (139) [serial 1002] used for:
  Initial proof obligations for Controller.impl
 


proof duration:  12.9 seconds 

done step:  axioms
Done executing proof script
closing dump.txt
closing dump.txt file "D:\AADL\BHA\osate2\dump.txt"
closing dump.txt file; 